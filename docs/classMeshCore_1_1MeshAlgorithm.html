<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeCAD: MeshCore::MeshAlgorithm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="width.css" rel="stylesheet" type="text/css"/>
<link href="details.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeCAD
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MeshCore</b></li><li class="navelem"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html">MeshAlgorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMeshCore_1_1MeshAlgorithm-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MeshCore::MeshAlgorithm Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Mod/Mesh/App/Core/Algorithm.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classMeshCore_1_1MeshAlgorithm.html">MeshAlgorithm</a> class provides algorithms base on meshes. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a329795bf21cde57f1ae14bb4fce049fa"><td class="memItemLeft" align="right" valign="top"><a id="a329795bf21cde57f1ae14bb4fce049fa"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a329795bf21cde57f1ae14bb4fce049fa">MeshAlgorithm</a> (const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;rclM)</td></tr>
<tr class="memdesc:a329795bf21cde57f1ae14bb4fce049fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction. <br /></td></tr>
<tr class="separator:a329795bf21cde57f1ae14bb4fce049fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418cae8769ee1cdbd7d66522177143be"><td class="memItemLeft" align="right" valign="top"><a id="a418cae8769ee1cdbd7d66522177143be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a418cae8769ee1cdbd7d66522177143be">~MeshAlgorithm</a> (void)</td></tr>
<tr class="memdesc:a418cae8769ee1cdbd7d66522177143be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruction. <br /></td></tr>
<tr class="separator:a418cae8769ee1cdbd7d66522177143be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088a2bded091b065da627a27ee68633b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a088a2bded091b065da627a27ee68633b">NearestFacetOnRay</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPt, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclDir, <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclRes, unsigned long &amp;rulFacet) const</td></tr>
<tr class="separator:a088a2bded091b065da627a27ee68633b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f833e7461e3892eee4475ad13e8b91"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a95f833e7461e3892eee4475ad13e8b91">NearestFacetOnRay</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPt, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclDir, const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclRes, unsigned long &amp;rulFacet) const</td></tr>
<tr class="separator:a95f833e7461e3892eee4475ad13e8b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff89886612e698be10eead651e12e44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a5ff89886612e698be10eead651e12e44">NearestFacetOnRay</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPt, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclDir, const std::vector&lt; unsigned long &gt; &amp;raulFacets, <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclRes, unsigned long &amp;rulFacet) const</td></tr>
<tr class="separator:a5ff89886612e698be10eead651e12e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3639c000a217faea622f2b138b715b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#aa3639c000a217faea622f2b138b715b7">NearestFacetOnRay</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPt, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclDir, float fMaxSearchArea, const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclRes, unsigned long &amp;rulFacet) const</td></tr>
<tr class="separator:aa3639c000a217faea622f2b138b715b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7755b56530d2c5900ed0877a2c37cb59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a7755b56530d2c5900ed0877a2c37cb59">FirstFacetToVertex</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPt, float fMaxDistance, const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, unsigned long &amp;rulFacet) const</td></tr>
<tr class="separator:a7755b56530d2c5900ed0877a2c37cb59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae365f02537cf93a1f78eefc1a1baccb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#ae365f02537cf93a1f78eefc1a1baccb9">IsVertexVisible</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rcVertex, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rcView, const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid) const</td></tr>
<tr class="separator:ae365f02537cf93a1f78eefc1a1baccb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45191e91289f12689608596f1e246c7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#af45191e91289f12689608596f1e246c7">GetAverageEdgeLength</a> () const</td></tr>
<tr class="separator:af45191e91289f12689608596f1e246c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c9223c336f53f9782294382a4f0eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a59c9223c336f53f9782294382a4f0eb1">GetGravityPoint</a> () const</td></tr>
<tr class="separator:a59c9223c336f53f9782294382a4f0eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d6523998431e6abddf9624abd9c09b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a01d6523998431e6abddf9624abd9c09b">GetMeshBorders</a> (std::list&lt; std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;rclBorders) const</td></tr>
<tr class="separator:a01d6523998431e6abddf9624abd9c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b49177ebd3f42bf1b62bb8669a5baed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a5b49177ebd3f42bf1b62bb8669a5baed">GetMeshBorders</a> (std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;rclBorders) const</td></tr>
<tr class="separator:a5b49177ebd3f42bf1b62bb8669a5baed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ec1256ed139fd32a29480fa7d0946a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a55ec1256ed139fd32a29480fa7d0946a">GetFacetBorders</a> (const std::vector&lt; unsigned long &gt; &amp;raulInd, std::list&lt; std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;rclBorders) const</td></tr>
<tr class="separator:a55ec1256ed139fd32a29480fa7d0946a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507c56572a40c9a88d3473ac09657ec2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a507c56572a40c9a88d3473ac09657ec2">GetFacetBorders</a> (const std::vector&lt; unsigned long &gt; &amp;raulInd, std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;rclBorders, bool ignoreOrientation=false) const</td></tr>
<tr class="separator:a507c56572a40c9a88d3473ac09657ec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fb6f576290a9b1646001a20dbea19e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a7fb6f576290a9b1646001a20dbea19e4">GetMeshBorder</a> (unsigned long uFacet, std::list&lt; unsigned long &gt; &amp;rBorder) const</td></tr>
<tr class="separator:a7fb6f576290a9b1646001a20dbea19e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2d0578db3d38d5818d0c598903cd94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a6a2d0578db3d38d5818d0c598903cd94">SplitBoundaryLoops</a> (std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;aBorders)</td></tr>
<tr class="separator:a6a2d0578db3d38d5818d0c598903cd94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d0dcdcbc73b9a3ce65f05fc56bbbce1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a7d0dcdcbc73b9a3ce65f05fc56bbbce1">FillupHole</a> (const std::vector&lt; unsigned long &gt; &amp;boundary, AbstractPolygonTriangulator &amp;cTria, <a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;rFaces, <a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;rPoints, int level, const <a class="el" href="classMeshCore_1_1MeshRefPointToFacets.html">MeshRefPointToFacets</a> *pP2FStructure=0) const</td></tr>
<tr class="separator:a7d0dcdcbc73b9a3ce65f05fc56bbbce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede251c64b23e177d4d7c30ec0fd63e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#aede251c64b23e177d4d7c30ec0fd63e1">SetFacetsProperty</a> (const std::vector&lt; unsigned long &gt; &amp;raulInds, const std::vector&lt; unsigned long &gt; &amp;raulProps) const</td></tr>
<tr class="separator:aede251c64b23e177d4d7c30ec0fd63e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af314d3dc77b706e6d77ed1cced1f15ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#af314d3dc77b706e6d77ed1cced1f15ab">SetFacetFlag</a> (MeshFacet::TFlagType tF) const</td></tr>
<tr class="separator:af314d3dc77b706e6d77ed1cced1f15ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750dd5a7ffdc39a0ba6ebca90f34955b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a750dd5a7ffdc39a0ba6ebca90f34955b">SetPointFlag</a> (MeshPoint::TFlagType tF) const</td></tr>
<tr class="separator:a750dd5a7ffdc39a0ba6ebca90f34955b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75ca9494624fc4c8c06cd31bc15c777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#af75ca9494624fc4c8c06cd31bc15c777">ResetFacetFlag</a> (MeshFacet::TFlagType tF) const</td></tr>
<tr class="separator:af75ca9494624fc4c8c06cd31bc15c777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7228d284c50a676f986dd6d6906c191e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a7228d284c50a676f986dd6d6906c191e">ResetPointFlag</a> (MeshPoint::TFlagType tF) const</td></tr>
<tr class="separator:a7228d284c50a676f986dd6d6906c191e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856d9c894a882cac8dd301bc6b0415d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a856d9c894a882cac8dd301bc6b0415d6">SetFacetsFlag</a> (const std::vector&lt; unsigned long &gt; &amp;raulInds, MeshFacet::TFlagType tF) const</td></tr>
<tr class="separator:a856d9c894a882cac8dd301bc6b0415d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caecf82406de7d1b98e4f4888f98b67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a9caecf82406de7d1b98e4f4888f98b67">SetPointsFlag</a> (const std::vector&lt; unsigned long &gt; &amp;raulInds, MeshPoint::TFlagType tF) const</td></tr>
<tr class="separator:a9caecf82406de7d1b98e4f4888f98b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668b4005cd818969918aa25fe26ef382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a668b4005cd818969918aa25fe26ef382">GetFacetsFlag</a> (std::vector&lt; unsigned long &gt; &amp;raulInds, MeshFacet::TFlagType tF) const</td></tr>
<tr class="separator:a668b4005cd818969918aa25fe26ef382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f633556aa9c5ce5a691f57e42e5a64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a97f633556aa9c5ce5a691f57e42e5a64">GetPointsFlag</a> (std::vector&lt; unsigned long &gt; &amp;raulInds, MeshPoint::TFlagType tF) const</td></tr>
<tr class="separator:a97f633556aa9c5ce5a691f57e42e5a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f966a91292e92517cf122535d407204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a1f966a91292e92517cf122535d407204">ResetFacetsFlag</a> (const std::vector&lt; unsigned long &gt; &amp;raulInds, MeshFacet::TFlagType tF) const</td></tr>
<tr class="separator:a1f966a91292e92517cf122535d407204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f52d673980f99bd5ff581807ea24e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a8f52d673980f99bd5ff581807ea24e73">ResetPointsFlag</a> (const std::vector&lt; unsigned long &gt; &amp;raulInds, MeshPoint::TFlagType tF) const</td></tr>
<tr class="separator:a8f52d673980f99bd5ff581807ea24e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac387be8ed93eeb48dc3166dcfab57eb6"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#ac387be8ed93eeb48dc3166dcfab57eb6">CountFacetFlag</a> (MeshFacet::TFlagType tF) const</td></tr>
<tr class="separator:ac387be8ed93eeb48dc3166dcfab57eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94720e005d361c171f33f91b4bb60e36"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a94720e005d361c171f33f91b4bb60e36">CountPointFlag</a> (MeshPoint::TFlagType tF) const</td></tr>
<tr class="separator:a94720e005d361c171f33f91b4bb60e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7494f2636ea7a07432a22aa0efa7b8a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a7494f2636ea7a07432a22aa0efa7b8a4">PointsFromFacetsIndices</a> (const std::vector&lt; unsigned long &gt; &amp;rvecIndices, std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;rvecPoints) const</td></tr>
<tr class="separator:a7494f2636ea7a07432a22aa0efa7b8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33180b09b89c89a26dd02a20b7a0e41b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a33180b09b89c89a26dd02a20b7a0e41b">GetFacetsFromToolMesh</a> (const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;rToolMesh, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rcDir, std::vector&lt; unsigned long &gt; &amp;raclCutted) const</td></tr>
<tr class="separator:a33180b09b89c89a26dd02a20b7a0e41b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486078fea387e491ddd32e674b17bc7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a486078fea387e491ddd32e674b17bc7f">GetFacetsFromToolMesh</a> (const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;rToolMesh, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rcDir, const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rGrid, std::vector&lt; unsigned long &gt; &amp;raclCutted) const</td></tr>
<tr class="separator:a486078fea387e491ddd32e674b17bc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb36a5f7063f25a76739e5caa3fe66ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#acb36a5f7063f25a76739e5caa3fe66ca">Surround</a> (const <a class="el" href="classBase_1_1BoundBox3.html">Base::BoundBox3f</a> &amp;rBox, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rcDir)</td></tr>
<tr class="separator:acb36a5f7063f25a76739e5caa3fe66ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0ba8e32d9e15b7128839f63d6b416d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#aaf0ba8e32d9e15b7128839f63d6b416d">CheckFacets</a> (const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, const <a class="el" href="classBase_1_1ViewProjMethod.html">Base::ViewProjMethod</a> *pclProj, const <a class="el" href="classBase_1_1Polygon2d.html">Base::Polygon2d</a> &amp;rclPoly, bool bInner, std::vector&lt; unsigned long &gt; &amp;rclRes) const</td></tr>
<tr class="separator:aaf0ba8e32d9e15b7128839f63d6b416d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdbac0bcc8bffcf1e139fb97b5bd034a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#abdbac0bcc8bffcf1e139fb97b5bd034a">CheckFacets</a> (const <a class="el" href="classBase_1_1ViewProjMethod.html">Base::ViewProjMethod</a> *pclProj, const <a class="el" href="classBase_1_1Polygon2d.html">Base::Polygon2d</a> &amp;rclPoly, bool bInner, std::vector&lt; unsigned long &gt; &amp;rclRes) const</td></tr>
<tr class="separator:abdbac0bcc8bffcf1e139fb97b5bd034a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883c213eacfb4973c6f274eef77781cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a883c213eacfb4973c6f274eef77781cd">CheckBorderFacets</a> (const std::vector&lt; unsigned long &gt; &amp;raclFacetIndices, std::vector&lt; unsigned long &gt; &amp;raclResultIndices, unsigned short usLevel=1) const</td></tr>
<tr class="separator:a883c213eacfb4973c6f274eef77781cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d1ebc4b647b9060b2b5402bb4c1c569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a5d1ebc4b647b9060b2b5402bb4c1c569">CutBorderFacets</a> (std::vector&lt; unsigned long &gt; &amp;raclFacetIndices, unsigned short usLevel=1) const</td></tr>
<tr class="separator:a5d1ebc4b647b9060b2b5402bb4c1c569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6642e3c3bf584daeca04bf5ef53de4"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#aff6642e3c3bf584daeca04bf5ef53de4">CountBorderEdges</a> () const</td></tr>
<tr class="separator:aff6642e3c3bf584daeca04bf5ef53de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511eab31680faf75eb961b1e3a45f27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a511eab31680faf75eb961b1e3a45f27a">GetBorderPoints</a> (const std::vector&lt; unsigned long &gt; &amp;raclFacetIndices, std::set&lt; unsigned long &gt; &amp;raclResultPointsIndices) const</td></tr>
<tr class="separator:a511eab31680faf75eb961b1e3a45f27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6a8cbb5b854f1d59971387d0988ae8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a9b6a8cbb5b854f1d59971387d0988ae8">Surface</a> (void) const</td></tr>
<tr class="separator:a9b6a8cbb5b854f1d59971387d0988ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d5e55f22dcadcb4f6b81ff630155d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a18d5e55f22dcadcb4f6b81ff630155d2">SubSampleByDist</a> (float fDist, std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;rclPoints) const</td></tr>
<tr class="separator:a18d5e55f22dcadcb4f6b81ff630155d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405ee673f35918bfbcb65e618913a7f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a405ee673f35918bfbcb65e618913a7f1">SubSampleByCount</a> (unsigned long ulCtPoints, std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;rclPoints) const</td></tr>
<tr class="separator:a405ee673f35918bfbcb65e618913a7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14e1fd527268450ac31e51be0653530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#aa14e1fd527268450ac31e51be0653530">SubSampleAllPoints</a> (std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;rclPoints) const</td></tr>
<tr class="separator:aa14e1fd527268450ac31e51be0653530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d0c7d766c7561466d5d671d6991214"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a60d0c7d766c7561466d5d671d6991214">SearchFacetsFromPolyline</a> (const std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;rclPolyline, float fRadius, const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, std::vector&lt; unsigned long &gt; &amp;rclResultFacetsIndices) const</td></tr>
<tr class="separator:a60d0c7d766c7561466d5d671d6991214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fd87e9c44005cf0da46c133693b27c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a50fd87e9c44005cf0da46c133693b27c">NearestPointFromPoint</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPt, unsigned long &amp;rclResFacetIndex, <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclResPoint) const</td></tr>
<tr class="separator:a50fd87e9c44005cf0da46c133693b27c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221ee20316d212e1169220d463d09683"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a221ee20316d212e1169220d463d09683">CutWithPlane</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;clBase, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;clNormal, const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, std::list&lt; std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;rclResult, float fMinEps=1.0e-2f, bool bConnectPolygons=false) const</td></tr>
<tr class="separator:a221ee20316d212e1169220d463d09683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0409036bdf6915916d447f630e350a99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a0409036bdf6915916d447f630e350a99">GetFacetsFromPlane</a> (const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;clNormal, float dist, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclLeft, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclRight, std::vector&lt; unsigned long &gt; &amp;rclRes) const</td></tr>
<tr class="separator:a0409036bdf6915916d447f630e350a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff6ab32f309ad4e39b01f97626ab60d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#afff6ab32f309ad4e39b01f97626ab60d">Distance</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPt, unsigned long ulFacetIdx, float fMaxDistance, float &amp;rfDistance) const</td></tr>
<tr class="separator:afff6ab32f309ad4e39b01f97626ab60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa655c80859b79269df0e743e5479f7ae"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#aa655c80859b79269df0e743e5479f7ae">CalculateMinimumGridLength</a> (float fLength, const <a class="el" href="classBase_1_1BoundBox3.html">Base::BoundBox3f</a> &amp;rBBox, unsigned long maxElements) const</td></tr>
<tr class="separator:aa655c80859b79269df0e743e5479f7ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:afcd082790b70f45ec2b6a64eec8d3908"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#afcd082790b70f45ec2b6a64eec8d3908">ConnectLines</a> (std::list&lt; std::pair&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a>, <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;rclLines, std::list&lt; std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;rclPolylines, float fMinEps) const</td></tr>
<tr class="separator:afcd082790b70f45ec2b6a64eec8d3908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf24332a1d64249cb30a1d38c56764f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#abf24332a1d64249cb30a1d38c56764f8">RayNearestField</a> (const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPt, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclDir, const std::vector&lt; unsigned long &gt; &amp;raulFacets, <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclRes, unsigned long &amp;rulFacet, float fMaxAngle=Mathf::PI) const</td></tr>
<tr class="separator:abf24332a1d64249cb30a1d38c56764f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461f6459db1a92b5af6a2eb9da2d6ac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a461f6459db1a92b5af6a2eb9da2d6ac8">SplitBoundaryLoops</a> (const std::vector&lt; unsigned long &gt; &amp;rBound, std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;aBorders)</td></tr>
<tr class="separator:a461f6459db1a92b5af6a2eb9da2d6ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a418373fcf40178b9923fba27804ca192"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a418373fcf40178b9923fba27804ca192">_rclMesh</a></td></tr>
<tr class="separator:a418373fcf40178b9923fba27804ca192"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa655c80859b79269df0e743e5479f7ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa655c80859b79269df0e743e5479f7ae">&#9670;&nbsp;</a></span>CalculateMinimumGridLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MeshCore::MeshAlgorithm::CalculateMinimumGridLength </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1BoundBox3.html">Base::BoundBox3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rBBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>maxElements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the minimum grid length so that not more elements than <em>maxElements</em> will be created when the grid gets built up. The minimum grid length must be at least <em>fLength</em>. </p>

</div>
</div>
<a id="a883c213eacfb4973c6f274eef77781cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883c213eacfb4973c6f274eef77781cd">&#9670;&nbsp;</a></span>CheckBorderFacets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::CheckBorderFacets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclFacetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclResultIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>usLevel</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines all facets of the given array <em>raclFacetIndices</em> that lie at the edge or that have at least neighbour facet that is not inside the array. The resulting array <em>raclResultIndices</em> is not be deleted before the algorithm starts. <em>usLevel</em> indicates how often the algorithm is repeated. </p>

</div>
</div>
<a id="aaf0ba8e32d9e15b7128839f63d6b416d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0ba8e32d9e15b7128839f63d6b416d">&#9670;&nbsp;</a></span>CheckFacets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::CheckFacets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1ViewProjMethod.html">Base::ViewProjMethod</a> *&#160;</td>
          <td class="paramname"><em>pclProj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Polygon2d.html">Base::Polygon2d</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects the determined facets through projection with <em>pclProj</em> into the 2D plane and checks for intersection with the polygon. If <em>bInner</em> is <em>true</em> than all facets with at least one corner inside the polygon get deleted. If <em>bInner</em> is <em>false</em> then all facets with at least one corner outside the polygon get deleted. This algorithm is optimized by using a grid. </p>

</div>
</div>
<a id="abdbac0bcc8bffcf1e139fb97b5bd034a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdbac0bcc8bffcf1e139fb97b5bd034a">&#9670;&nbsp;</a></span>CheckFacets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::CheckFacets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1ViewProjMethod.html">Base::ViewProjMethod</a> *&#160;</td>
          <td class="paramname"><em>pclProj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Polygon2d.html">Base::Polygon2d</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does the same as the above method unless that it doesn't use a grid. </p>

</div>
</div>
<a id="afcd082790b70f45ec2b6a64eec8d3908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd082790b70f45ec2b6a64eec8d3908">&#9670;&nbsp;</a></span>ConnectLines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::ConnectLines </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::pair&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a>, <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclPolylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMinEps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper method to connect the intersection points to polylines. </p>

</div>
</div>
<a id="aff6642e3c3bf584daeca04bf5ef53de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6642e3c3bf584daeca04bf5ef53de4">&#9670;&nbsp;</a></span>CountBorderEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MeshCore::MeshAlgorithm::CountBorderEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of border edges </p>

</div>
</div>
<a id="ac387be8ed93eeb48dc3166dcfab57eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac387be8ed93eeb48dc3166dcfab57eb6">&#9670;&nbsp;</a></span>CountFacetFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MeshCore::MeshAlgorithm::CountFacetFlag </td>
          <td>(</td>
          <td class="paramtype">MeshFacet::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count all facets with the flag <em>tF</em>. </p>

</div>
</div>
<a id="a94720e005d361c171f33f91b4bb60e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94720e005d361c171f33f91b4bb60e36">&#9670;&nbsp;</a></span>CountPointFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MeshCore::MeshAlgorithm::CountPointFlag </td>
          <td>(</td>
          <td class="paramtype">MeshPoint::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count all points with the flag <em>tF</em>. </p>

</div>
</div>
<a id="a5d1ebc4b647b9060b2b5402bb4c1c569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d1ebc4b647b9060b2b5402bb4c1c569">&#9670;&nbsp;</a></span>CutBorderFacets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::CutBorderFacets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclFacetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>usLevel</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invokes <a class="el" href="classMeshCore_1_1MeshAlgorithm.html#a883c213eacfb4973c6f274eef77781cd">CheckBorderFacets()</a> to get all border facets of <em>raclFacetIndices</em>. Then the content of <em>raclFacetIndices</em> is replaced by all facets that can be deleted. </p><dl class="section note"><dt>Note</dt><dd>The mesh structure is not modified by this method. This is in the responsibility of the user. </dd></dl>

</div>
</div>
<a id="a221ee20316d212e1169220d463d09683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a221ee20316d212e1169220d463d09683">&#9670;&nbsp;</a></span>CutWithPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::CutWithPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>clBase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>clNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMinEps</em> = <code>1.0e-2f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bConnectPolygons</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cuts the mesh with a plane. The result is a list of polylines. </p>

</div>
</div>
<a id="afff6ab32f309ad4e39b01f97626ab60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff6ab32f309ad4e39b01f97626ab60d">&#9670;&nbsp;</a></span>Distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::Distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMaxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>rfDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the distance from the <em>rclPt</em> to the facet <em>ulFacetIdx</em> is less than <em>fMaxDistance</em>. If this restriction is met <em>rfDistance</em> is set to the actual distance, otherwise false is returned. </p>

</div>
</div>
<a id="a7d0dcdcbc73b9a3ce65f05fc56bbbce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d0dcdcbc73b9a3ce65f05fc56bbbce1">&#9670;&nbsp;</a></span>FillupHole()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::FillupHole </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AbstractPolygonTriangulator &amp;&#160;</td>
          <td class="paramname"><em>cTria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshRefPointToFacets.html">MeshRefPointToFacets</a> *&#160;</td>
          <td class="paramname"><em>pP2FStructure</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills up the single boundary if it is a hole with high quality triangles and a maximum area of <em>fMaxArea</em>. The triangulation information is stored in <em>rFaces</em> and <em>rPoints</em>. To speed up the calculations the optional parameter <em>pStructure</em> can be specified that holds a facet-to-points structure of the underlying mesh. If the boundary is not a hole or the algorithm failed false is returned, otherwise true. </p><dl class="section note"><dt>Note</dt><dd><em>boundary</em> contains the point indices of the mesh data structure. The first and last index must therefore be equal. </dd>
<dd>
<em>rPoints</em> contains the geometric points of the triangulation. The number of points can be the same as or exceed the number of boundary indices but it cannot be lower. </dd>
<dd>
If the number of geometric points exceeds the number of boundary indices then the triangulation algorithm has introduced new points which are added to the end of <em>rPoints</em>. </dd></dl>

</div>
</div>
<a id="a7755b56530d2c5900ed0877a2c37cb59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7755b56530d2c5900ed0877a2c37cb59">&#9670;&nbsp;</a></span>FirstFacetToVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::FirstFacetToVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMaxDistance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulFacet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the first facet of the grid element (<em>rclGrid</em>) in that the point <em>rclPt</em> lies into which is a distance not higher than <em>fMaxDistance</em>. Of no such facet is found <em>rulFacet</em> is undefined and false is returned, otherwise true. </p><dl class="section note"><dt>Note</dt><dd>If the point <em>rclPt</em> is outside of the grid <em>rclGrid</em> nothing is done. </dd></dl>

</div>
</div>
<a id="af45191e91289f12689608596f1e246c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45191e91289f12689608596f1e246c7">&#9670;&nbsp;</a></span>GetAverageEdgeLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MeshCore::MeshAlgorithm::GetAverageEdgeLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the average length of edges. </p>

</div>
</div>
<a id="a511eab31680faf75eb961b1e3a45f27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511eab31680faf75eb961b1e3a45f27a">&#9670;&nbsp;</a></span>GetBorderPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetBorderPoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclFacetIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::set&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclResultPointsIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines all border points as indices of the facets in <em>raclFacetIndices</em>. The points are unsorted. </p>

</div>
</div>
<a id="a55ec1256ed139fd32a29480fa7d0946a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55ec1256ed139fd32a29480fa7d0946a">&#9670;&nbsp;</a></span>GetFacetBorders() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetFacetBorders </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclBorders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all boundaries of a subset the mesh defined by <em>raulInd</em>. </p>

</div>
</div>
<a id="a507c56572a40c9a88d3473ac09657ec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507c56572a40c9a88d3473ac09657ec2">&#9670;&nbsp;</a></span>GetFacetBorders() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetFacetBorders </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclBorders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreOrientation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all boundaries of a subset the mesh defined by <em>raulInd</em>. This method does basically the same as above unless that it returns the point indices of the boundaries. If <em>ignoreOrientation</em> is false (the default) we may get a broken boundary curve if the mesh has facets with wrong orientation. However, if <em>ignoreOrientation</em> is true we may get a boundary curve with wrong orientation even if the mesh is topologically correct. You should let the default value unless you exactly know what you do. </p>

</div>
</div>
<a id="a668b4005cd818969918aa25fe26ef382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668b4005cd818969918aa25fe26ef382">&#9670;&nbsp;</a></span>GetFacetsFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetFacetsFlag </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshFacet::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets all facets in <em>raulInds</em> with the flag <em>tF</em>. </p>

</div>
</div>
<a id="a0409036bdf6915916d447f630e350a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0409036bdf6915916d447f630e350a99">&#9670;&nbsp;</a></span>GetFacetsFromPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetFacetsFromPlane </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>clNormal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclLeft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclRight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclRes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets all facets that cut the plane (N,d) and that lie between the two points left and right. The plane is defined by it normalized normal and the signed distance to the origin. </p>

</div>
</div>
<a id="a33180b09b89c89a26dd02a20b7a0e41b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33180b09b89c89a26dd02a20b7a0e41b">&#9670;&nbsp;</a></span>GetFacetsFromToolMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetFacetsFromToolMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td>
          <td class="paramname"><em>rToolMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rcDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclCutted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the indices of all facets that have at least one point that lies inside the tool mesh. The direction <em>dir</em> is used to try to foraminate the facets of the tool mesh and counts the number of foraminated facets. If this number is odd the considered point lies inside otherwise outside. </p><dl class="section note"><dt>Note</dt><dd>The tool mesh must be a valid solid. </dd>
<dd>
It's not tested if <em>rToolMesh</em> is a valid solid. In case it is not the result is undefined. </dd></dl>

</div>
</div>
<a id="a486078fea387e491ddd32e674b17bc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486078fea387e491ddd32e674b17bc7f">&#9670;&nbsp;</a></span>GetFacetsFromToolMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetFacetsFromToolMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td>
          <td class="paramname"><em>rToolMesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rcDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclCutted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does basically the same as method above except it uses a mesh grid to speed up the computation. </p>

</div>
</div>
<a id="a59c9223c336f53f9782294382a4f0eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c9223c336f53f9782294382a4f0eb1">&#9670;&nbsp;</a></span>GetGravityPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> MeshCore::MeshAlgorithm::GetGravityPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the gravity point of the mesh. </p>

</div>
</div>
<a id="a7fb6f576290a9b1646001a20dbea19e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fb6f576290a9b1646001a20dbea19e4">&#9670;&nbsp;</a></span>GetMeshBorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetMeshBorder </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>uFacet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>rBorder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the boundary of the mesh to the facet <em>uFacet</em>. If this facet does not have an open edge the returned boundary is empty. </p>

</div>
</div>
<a id="a01d6523998431e6abddf9624abd9c09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d6523998431e6abddf9624abd9c09b">&#9670;&nbsp;</a></span>GetMeshBorders() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetMeshBorders </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclBorders</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all boundaries of the mesh. </p>

</div>
</div>
<a id="a5b49177ebd3f42bf1b62bb8669a5baed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b49177ebd3f42bf1b62bb8669a5baed">&#9670;&nbsp;</a></span>GetMeshBorders() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetMeshBorders </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclBorders</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all boundaries of the mesh. This method does basically the same as above unless that it returns the point indices of the boundaries. </p>

</div>
</div>
<a id="a97f633556aa9c5ce5a691f57e42e5a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f633556aa9c5ce5a691f57e42e5a64">&#9670;&nbsp;</a></span>GetPointsFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::GetPointsFlag </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshPoint::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets all points in <em>raulInds</em> with the flag <em>tF</em>. </p>

</div>
</div>
<a id="ae365f02537cf93a1f78eefc1a1baccb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae365f02537cf93a1f78eefc1a1baccb9">&#9670;&nbsp;</a></span>IsVertexVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::IsVertexVisible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rcVertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rcView</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks from the viewpoint <em>rcView</em> if the vertex <em>rcVertex</em> is visible or it is hidden by a facet. If the vertex is visible true is returned, false otherwise. </p>

</div>
</div>
<a id="a088a2bded091b065da627a27ee68633b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088a2bded091b065da627a27ee68633b">&#9670;&nbsp;</a></span>NearestFacetOnRay() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::NearestFacetOnRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulFacet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the nearest facet to the ray defined by (<em>rclPt</em>, <em>rclDir</em>). The point <em>rclRes</em> holds the intersection point with the ray and the nearest facet with index <em>rulFacet</em>. </p><dl class="section note"><dt>Note</dt><dd>This method tests all facets so it should only be used occasionally. </dd></dl>

</div>
</div>
<a id="a95f833e7461e3892eee4475ad13e8b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f833e7461e3892eee4475ad13e8b91">&#9670;&nbsp;</a></span>NearestFacetOnRay() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::NearestFacetOnRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulFacet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the nearest facet to the ray defined by (<em>rclPt</em>, <em>rclDir</em>). The point <em>rclRes</em> holds the intersection point with the ray and the nearest facet with index <em>rulFacet</em>. </p><dl class="section note"><dt>Note</dt><dd>This method is optimized by using a grid. So this method can be used for a lot of tests. </dd></dl>

</div>
</div>
<a id="a5ff89886612e698be10eead651e12e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff89886612e698be10eead651e12e44">&#9670;&nbsp;</a></span>NearestFacetOnRay() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::NearestFacetOnRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulFacets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulFacet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the nearest facet to the ray defined by (<em>rclPt</em>, <em>rclDir</em>). The point <em>rclRes</em> holds the intersection point with the ray and the nearest facet with index <em>rulFacet</em>. </p><dl class="section note"><dt>Note</dt><dd>This method tests all facets taken from <em>raulFacets</em> instead of the attached mesh. So the caller must ensure that the indices are valid facets. </dd></dl>

</div>
</div>
<a id="aa3639c000a217faea622f2b138b715b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3639c000a217faea622f2b138b715b7">&#9670;&nbsp;</a></span>NearestFacetOnRay() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::NearestFacetOnRay </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMaxSearchArea</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulFacet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for the nearest facet to the ray defined by (<em>rclPt</em>, <em>rclDir</em>). The point <em>rclRes</em> holds the intersection point with the ray and the nearest facet with index <em>rulFacet</em>. More a search radius around the ray of <em>fMaxSearchArea</em> is defined. </p><dl class="section note"><dt>Note</dt><dd>This method is optimized by using a grid. So this method can be used for a lot of tests. </dd></dl>

</div>
</div>
<a id="a50fd87e9c44005cf0da46c133693b27c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fd87e9c44005cf0da46c133693b27c">&#9670;&nbsp;</a></span>NearestPointFromPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::NearestPointFromPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rclResFacetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclResPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Projects a point directly to the mesh (means nearest facet), the result is the facet index and the foraminate point, use second version with grid for more performance. </p>

</div>
</div>
<a id="a7494f2636ea7a07432a22aa0efa7b8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7494f2636ea7a07432a22aa0efa7b8a4">&#9670;&nbsp;</a></span>PointsFromFacetsIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::PointsFromFacetsIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>rvecIndices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rvecPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all geometric points from the facets in <em>rvecIndices</em>. </p>

</div>
</div>
<a id="abf24332a1d64249cb30a1d38c56764f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf24332a1d64249cb30a1d38c56764f8">&#9670;&nbsp;</a></span>RayNearestField()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshAlgorithm::RayNearestField </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulFacets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclRes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulFacet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMaxAngle</em> = <code>Mathf::PI</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the nearest facet in <em>raulFacets</em> to the ray (<em>rclPt</em>, <em>rclDir</em>). </p>

</div>
</div>
<a id="af75ca9494624fc4c8c06cd31bc15c777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75ca9494624fc4c8c06cd31bc15c777">&#9670;&nbsp;</a></span>ResetFacetFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::ResetFacetFlag </td>
          <td>(</td>
          <td class="paramtype">MeshFacet::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets of all facets the flag <em>tF</em>. </p>

</div>
</div>
<a id="a1f966a91292e92517cf122535d407204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f966a91292e92517cf122535d407204">&#9670;&nbsp;</a></span>ResetFacetsFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::ResetFacetsFlag </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshFacet::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets from all facets in <em>raulInds</em> the flag <em>tF</em>. </p>

</div>
</div>
<a id="a7228d284c50a676f986dd6d6906c191e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7228d284c50a676f986dd6d6906c191e">&#9670;&nbsp;</a></span>ResetPointFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::ResetPointFlag </td>
          <td>(</td>
          <td class="paramtype">MeshPoint::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets of all points the flag <em>tF</em>. </p>

</div>
</div>
<a id="a8f52d673980f99bd5ff581807ea24e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f52d673980f99bd5ff581807ea24e73">&#9670;&nbsp;</a></span>ResetPointsFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::ResetPointsFlag </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshPoint::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets from all points in <em>raulInds</em> the flag <em>tF</em>. </p>

</div>
</div>
<a id="a60d0c7d766c7561466d5d671d6991214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60d0c7d766c7561466d5d671d6991214">&#9670;&nbsp;</a></span>SearchFacetsFromPolyline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SearchFacetsFromPolyline </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclPolyline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fRadius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclResultFacetsIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches for all facets that intersect the "search tube" with radius <em>r</em> around the polyline. </p>

</div>
</div>
<a id="af314d3dc77b706e6d77ed1cced1f15ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af314d3dc77b706e6d77ed1cced1f15ab">&#9670;&nbsp;</a></span>SetFacetFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SetFacetFlag </td>
          <td>(</td>
          <td class="paramtype">MeshFacet::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets to all facets the flag <em>tF</em>. </p>

</div>
</div>
<a id="a856d9c894a882cac8dd301bc6b0415d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856d9c894a882cac8dd301bc6b0415d6">&#9670;&nbsp;</a></span>SetFacetsFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SetFacetsFlag </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshFacet::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets to all facets in <em>raulInds</em> the flag <em>tF</em>. </p>

</div>
</div>
<a id="aede251c64b23e177d4d7c30ec0fd63e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aede251c64b23e177d4d7c30ec0fd63e1">&#9670;&nbsp;</a></span>SetFacetsProperty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SetFacetsProperty </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets to all facets in <em>raulInds</em> the properties in raulProps. </p><dl class="section note"><dt>Note</dt><dd>Both arrays must have the same size. </dd></dl>

</div>
</div>
<a id="a750dd5a7ffdc39a0ba6ebca90f34955b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750dd5a7ffdc39a0ba6ebca90f34955b">&#9670;&nbsp;</a></span>SetPointFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SetPointFlag </td>
          <td>(</td>
          <td class="paramtype">MeshPoint::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets to all points the flag <em>tF</em>. </p>

</div>
</div>
<a id="a9caecf82406de7d1b98e4f4888f98b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9caecf82406de7d1b98e4f4888f98b67">&#9670;&nbsp;</a></span>SetPointsFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SetPointsFlag </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulInds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshPoint::TFlagType&#160;</td>
          <td class="paramname"><em>tF</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets to all points in <em>raulInds</em> the flag <em>tF</em>. </p>

</div>
</div>
<a id="a6a2d0578db3d38d5818d0c598903cd94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a2d0578db3d38d5818d0c598903cd94">&#9670;&nbsp;</a></span>SplitBoundaryLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SplitBoundaryLoops </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aBorders</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Boundaries that consist of several loops must be split in several independent boundaries to perform e.g. a polygon triangulation algorithm on them. </p>

</div>
</div>
<a id="a461f6459db1a92b5af6a2eb9da2d6ac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461f6459db1a92b5af6a2eb9da2d6ac8">&#9670;&nbsp;</a></span>SplitBoundaryLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SplitBoundaryLoops </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>rBound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aBorders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Splits the boundary <em>rBound</em> in several loops and append this loops to the list of borders. </p>

</div>
</div>
<a id="aa14e1fd527268450ac31e51be0653530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14e1fd527268450ac31e51be0653530">&#9670;&nbsp;</a></span>SubSampleAllPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SubSampleAllPoints </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclPoints</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns only the points of the mesh without actually sampling the data. </p>

</div>
</div>
<a id="a405ee673f35918bfbcb65e618913a7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a405ee673f35918bfbcb65e618913a7f1">&#9670;&nbsp;</a></span>SubSampleByCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SubSampleByCount </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulCtPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subsamples the mesh to produce around <em>ulCtPoints</em>. <em>ulCtPoints</em> should be greater than 5 * number of facets. </p>

</div>
</div>
<a id="a18d5e55f22dcadcb4f6b81ff630155d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d5e55f22dcadcb4f6b81ff630155d2">&#9670;&nbsp;</a></span>SubSampleByDist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshAlgorithm::SubSampleByDist </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fDist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclPoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subsamples the mesh with point distance <em>fDist</em> and stores the points in <em>rclPoints</em>. </p>

</div>
</div>
<a id="a9b6a8cbb5b854f1d59971387d0988ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6a8cbb5b854f1d59971387d0988ae8">&#9670;&nbsp;</a></span>Surface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MeshCore::MeshAlgorithm::Surface </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the surface of the mesh. </p>

</div>
</div>
<a id="acb36a5f7063f25a76739e5caa3fe66ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb36a5f7063f25a76739e5caa3fe66ca">&#9670;&nbsp;</a></span>Surround()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MeshCore::MeshAlgorithm::Surround </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1BoundBox3.html">Base::BoundBox3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rcDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the bounding box <em>rBox</em> is surrounded by the attached mesh which must be a solid. The direction <em>rcDir</em> is used to try to foraminate the facets of the tool mesh and counts the number of foraminated facets. 1 is returned if the box is completely inside the mesh 0 is returned if the box is partially inside (i.e. intersects) the mesh -1 is returned if the box is completely outside the mesh. This could also mean that the mesh is surrounded by <em>rBox</em>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a418373fcf40178b9923fba27804ca192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418373fcf40178b9923fba27804ca192">&#9670;&nbsp;</a></span>_rclMesh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a>&amp; MeshCore::MeshAlgorithm::_rclMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The mesh kernel. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 20 2019 19:26:09 for FreeCAD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
