<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeCAD: MeshCore::MeshTopoAlgorithm Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="width.css" rel="stylesheet" type="text/css"/>
<link href="details.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeCAD
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MeshCore</b></li><li class="navelem"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html">MeshTopoAlgorithm</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMeshCore_1_1MeshTopoAlgorithm-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MeshCore::MeshTopoAlgorithm Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Mod/Mesh/App/Core/TopoAlgorithm.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html">MeshTopoAlgorithm</a> class provides several algorithms to manipulate a mesh. It supports various mesh operations like inserting a new vertex, swapping the common edge of two adjacent facets, split a facet, ... </p><dl class="section author"><dt>Author</dt><dd>Werner Mayer </dd></dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0690aa64132bdc71e2420d2fe9af2de0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a0690aa64132bdc71e2420d2fe9af2de0">SnapVertex</a> (unsigned long ulFacetPos, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rP)</td></tr>
<tr class="separator:a0690aa64132bdc71e2420d2fe9af2de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c03ccd7df55dd64179eceffce010f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#ac8c03ccd7df55dd64179eceffce010f5">IsSwapEdgeLegal</a> (unsigned long ulFacetPos, unsigned long ulNeighbour) const</td></tr>
<tr class="separator:ac8c03ccd7df55dd64179eceffce010f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92250229e3717d4c991959f2285b8b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#ac92250229e3717d4c991959f2285b8b2">ShouldSwapEdge</a> (unsigned long ulFacetPos, unsigned long ulNeighbour, float fMaxAngle) const</td></tr>
<tr class="separator:ac92250229e3717d4c991959f2285b8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c146383a145b5639df13c3e711f8821"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a9c146383a145b5639df13c3e711f8821">SwapEdgeBenefit</a> (unsigned long f, int e) const</td></tr>
<tr class="separator:a9c146383a145b5639df13c3e711f8821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a523b67a3387c3b5dca2eaab011587bfc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a523b67a3387c3b5dca2eaab011587bfc">Cleanup</a> ()</td></tr>
<tr class="separator:a523b67a3387c3b5dca2eaab011587bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b08bfd54d2559608d4b113a14c0cbbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a3b08bfd54d2559608d4b113a14c0cbbb">RemoveDegeneratedFacet</a> (unsigned long index)</td></tr>
<tr class="separator:a3b08bfd54d2559608d4b113a14c0cbbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70953cbcff9599205fe7b497fc47086a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a70953cbcff9599205fe7b497fc47086a">RemoveCorruptedFacet</a> (unsigned long index)</td></tr>
<tr class="separator:a70953cbcff9599205fe7b497fc47086a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923a5d3ddd723c9d1b88a44f01f98455"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a923a5d3ddd723c9d1b88a44f01f98455">FillupHoles</a> (unsigned long length, int level, AbstractPolygonTriangulator &amp;, std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;aFailed)</td></tr>
<tr class="separator:a923a5d3ddd723c9d1b88a44f01f98455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a204251c3d14cfead66ed710c9ddf056f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a204251c3d14cfead66ed710c9ddf056f">FillupHoles</a> (int level, AbstractPolygonTriangulator &amp;, const std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;aBorders, std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;aFailed)</td></tr>
<tr class="separator:a204251c3d14cfead66ed710c9ddf056f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf27d1d45c8025fcd25e1df3b57c809"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a2bf27d1d45c8025fcd25e1df3b57c809">FindHoles</a> (unsigned long length, std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;aBorders) const</td></tr>
<tr class="separator:a2bf27d1d45c8025fcd25e1df3b57c809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5112506f115411782270df607b1136c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a5112506f115411782270df607b1136c7">FindComponents</a> (unsigned long count, std::vector&lt; unsigned long &gt; &amp;aInds)</td></tr>
<tr class="separator:a5112506f115411782270df607b1136c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4b71df73a74b8c6a5ebeb984d69e44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a4d4b71df73a74b8c6a5ebeb984d69e44">RemoveComponents</a> (unsigned long count)</td></tr>
<tr class="separator:a4d4b71df73a74b8c6a5ebeb984d69e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e11605db3f088012c3cf1476b0d3815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a0e11605db3f088012c3cf1476b0d3815">HarmonizeNormals</a> (void)</td></tr>
<tr class="separator:a0e11605db3f088012c3cf1476b0d3815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c3c802310a289b38911cb059406e68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a60c3c802310a289b38911cb059406e68">FlipNormals</a> (void)</td></tr>
<tr class="separator:a60c3c802310a289b38911cb059406e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09352502ee8c3bbe02e440c803339790"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a09352502ee8c3bbe02e440c803339790">BeginCache</a> ()</td></tr>
<tr class="separator:a09352502ee8c3bbe02e440c803339790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Topological Operations</div></td></tr>
<tr class="memitem:a2f70c92bb105665a849192cc1cbcf5e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a2f70c92bb105665a849192cc1cbcf5e1">InsertVertex</a> (unsigned long ulFacetPos, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPoint)</td></tr>
<tr class="separator:a2f70c92bb105665a849192cc1cbcf5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c287376020e6acc00ef1988c579fef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a1c287376020e6acc00ef1988c579fef2">InsertVertexAndSwapEdge</a> (unsigned long ulFacetPos, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclPoint, float fMaxAngle)</td></tr>
<tr class="separator:a1c287376020e6acc00ef1988c579fef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2be6ae8beacbda2efbbd7ed6103b9b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#ab2be6ae8beacbda2efbbd7ed6103b9b6">SwapEdge</a> (unsigned long ulFacetPos, unsigned long ulNeighbour)</td></tr>
<tr class="separator:ab2be6ae8beacbda2efbbd7ed6103b9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa674e256ecfb87ba13bdfdfb8c8934a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#aaa674e256ecfb87ba13bdfdfb8c8934a">SplitEdge</a> (unsigned long ulFacetPos, unsigned long ulNeighbour, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rP)</td></tr>
<tr class="separator:aaa674e256ecfb87ba13bdfdfb8c8934a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f9d2b609339619cf45d48c727e5d31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a82f9d2b609339619cf45d48c727e5d31">SplitOpenEdge</a> (unsigned long ulFacetPos, unsigned short uSide, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rP)</td></tr>
<tr class="separator:a82f9d2b609339619cf45d48c727e5d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7935625a21652cdf9b034019a6c8d940"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a7935625a21652cdf9b034019a6c8d940">SplitFacet</a> (unsigned long ulFacetPos, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rP1, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rP2)</td></tr>
<tr class="separator:a7935625a21652cdf9b034019a6c8d940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48653728911dd401e5687b3c14443ffe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a48653728911dd401e5687b3c14443ffe">CollapseVertex</a> (const VertexCollapse &amp;vc)</td></tr>
<tr class="separator:a48653728911dd401e5687b3c14443ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2f3fb67d722dcf9511b77ae42bf000"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#abb2f3fb67d722dcf9511b77ae42bf000">IsCollapseEdgeLegal</a> (const EdgeCollapse &amp;ec) const</td></tr>
<tr class="separator:abb2f3fb67d722dcf9511b77ae42bf000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9b0224aaf9fcf99268bf6e15636ecf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a6c9b0224aaf9fcf99268bf6e15636ecf">CollapseEdge</a> (unsigned long ulFacetPos, unsigned long ulNeighbour)</td></tr>
<tr class="separator:a6c9b0224aaf9fcf99268bf6e15636ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1752f1e1f8abd763859dad3e7b2297a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#ac1752f1e1f8abd763859dad3e7b2297a">CollapseEdge</a> (const EdgeCollapse &amp;ec)</td></tr>
<tr class="separator:ac1752f1e1f8abd763859dad3e7b2297a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218ce5017bf26cf51d919ceb063b4c4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a218ce5017bf26cf51d919ceb063b4c4b">CollapseFacet</a> (unsigned long ulFacetPos)</td></tr>
<tr class="separator:a218ce5017bf26cf51d919ceb063b4c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Topological Optimization</div></td></tr>
<tr class="memitem:a5b66e3d48bad86154ae237197a1d44e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a5b66e3d48bad86154ae237197a1d44e4">OptimizeTopology</a> (float fMaxAngle)</td></tr>
<tr class="separator:a5b66e3d48bad86154ae237197a1d44e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5875684606c1902a0f7fe0dcd5aee17"><td class="memItemLeft" align="right" valign="top"><a id="ae5875684606c1902a0f7fe0dcd5aee17"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>OptimizeTopology</b> ()</td></tr>
<tr class="separator:ae5875684606c1902a0f7fe0dcd5aee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1290d2617fa32653e3b6da34470e5c06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a1290d2617fa32653e3b6da34470e5c06">DelaunayFlip</a> (float fMaxAngle)</td></tr>
<tr class="separator:a1290d2617fa32653e3b6da34470e5c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3369411593d262126e79bcce48bc53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a5f3369411593d262126e79bcce48bc53">DelaunayFlip</a> ()</td></tr>
<tr class="separator:a5f3369411593d262126e79bcce48bc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9513e969ae6d5ecbedd383b23fcc54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#aba9513e969ae6d5ecbedd383b23fcc54">AdjustEdgesToCurvatureDirection</a> ()</td></tr>
<tr class="separator:aba9513e969ae6d5ecbedd383b23fcc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aba9513e969ae6d5ecbedd383b23fcc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9513e969ae6d5ecbedd383b23fcc54">&#9670;&nbsp;</a></span>AdjustEdgesToCurvatureDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::AdjustEdgesToCurvatureDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to adjust the edges to the curvature direction with the minimum absolute value of maximum and minimum curvature. </p><dl class="section note"><dt>Note</dt><dd>This is a high-level operation and tries to optimize the mesh as a whole. </dd></dl>

</div>
</div>
<a id="a09352502ee8c3bbe02e440c803339790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09352502ee8c3bbe02e440c803339790">&#9670;&nbsp;</a></span>BeginCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::BeginCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caching facility. </p>

</div>
</div>
<a id="a523b67a3387c3b5dca2eaab011587bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a523b67a3387c3b5dca2eaab011587bfc">&#9670;&nbsp;</a></span>Cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::Cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all invalid marked elements from the mesh structure. </p>

</div>
</div>
<a id="a6c9b0224aaf9fcf99268bf6e15636ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9b0224aaf9fcf99268bf6e15636ecf">&#9670;&nbsp;</a></span>CollapseEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::CollapseEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulNeighbour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collapses the common edge of two adjacent facets. This operation removes one common point of the collapsed edge and the facets <em>ulFacetPos</em> and <em>ulNeighbour</em> from the data structure. </p><dl class="section note"><dt>Note</dt><dd>If <em>ulNeighbour</em> is the neighbour facet on the i-th side of <em>ulFacetPos</em> then the i-th point is removed whereas i is 0, 1 or 2. If the other common point should be removed then <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a6c9b0224aaf9fcf99268bf6e15636ecf">CollapseEdge()</a> should be invoked with swapped arguments of <em>ulFacetPos</em> and <em>ulNeighbour</em>, i.e. CollapseEdge( <em>ulNeighbour</em>, <em>ulFacetPos</em> ).</dd>
<dd>
The client programmer must make sure that this is a legal operation.</dd>
<dd>
This method marks the facets and the point as 'invalid' but does not remove them from the mesh structure, i.e. the mesh structure gets into an inconsistent stage. To make the structure consistent again <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a523b67a3387c3b5dca2eaab011587bfc">Cleanup()</a> should be called. The reason why this cannot be done automatically is that it would become quite slow if a lot of edges should be collapsed.</dd>
<dd>
While the mesh structure has invalid elements the client programmer must take care not to use such elements. </dd></dl>

</div>
</div>
<a id="ac1752f1e1f8abd763859dad3e7b2297a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1752f1e1f8abd763859dad3e7b2297a">&#9670;&nbsp;</a></span>CollapseEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::CollapseEdge </td>
          <td>(</td>
          <td class="paramtype">const EdgeCollapse &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience function that passes already all needed information. </p>

</div>
</div>
<a id="a218ce5017bf26cf51d919ceb063b4c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218ce5017bf26cf51d919ceb063b4c4b">&#9670;&nbsp;</a></span>CollapseFacet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::CollapseFacet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the facet with index <em>ulFacetPos</em> and all its neighbour facets. The three vertices that are referenced by this facet are replaced by its gravity point.</p>
<dl class="section note"><dt>Note</dt><dd>The client programmer must make sure that this is a legal operation.</dd>
<dd>
This method marks the facets and the point as 'invalid' but does not remove them from the mesh structure, i.e. the mesh structure gets into an inconsistent stage. To make the structure consistent again <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a523b67a3387c3b5dca2eaab011587bfc">Cleanup()</a> should be called. The reason why this cannot be done automatically is that it would become quite slow if a lot of facets should be collapsed.</dd>
<dd>
While the mesh structure has invalid elements the client programmer must take care not to use such elements. </dd></dl>

</div>
</div>
<a id="a48653728911dd401e5687b3c14443ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48653728911dd401e5687b3c14443ffe">&#9670;&nbsp;</a></span>CollapseVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::CollapseVertex </td>
          <td>(</td>
          <td class="paramtype">const VertexCollapse &amp;&#160;</td>
          <td class="paramname"><em>vc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collapse a vertex. At the moment only removing inner vertexes referenced by three facets is supposrted. </p>

</div>
</div>
<a id="a1290d2617fa32653e3b6da34470e5c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1290d2617fa32653e3b6da34470e5c06">&#9670;&nbsp;</a></span>DelaunayFlip() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::DelaunayFlip </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMaxAngle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to make a more beautiful mesh by swapping the common edge of two adjacent facets where needed. A swap is needed where two adjacent facets don't fulfill the Delaunay condition. </p>

</div>
</div>
<a id="a5f3369411593d262126e79bcce48bc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3369411593d262126e79bcce48bc53">&#9670;&nbsp;</a></span>DelaunayFlip() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int MeshCore::MeshTopoAlgorithm::DelaunayFlip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded method DelaunayFlip that doesn't use ShouldSwapEdge to check for legal swap edge. </p>

</div>
</div>
<a id="a923a5d3ddd723c9d1b88a44f01f98455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923a5d3ddd723c9d1b88a44f01f98455">&#9670;&nbsp;</a></span>FillupHoles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::FillupHoles </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AbstractPolygonTriangulator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aFailed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes holes in the mesh that consists of up to <em>length</em> edges. In case a fit needs to be done then the points of the neighbours of <em>level</em> rings will be used. Holes for which the triangulation failed are returned in <em>aFailed</em>. </p>

</div>
</div>
<a id="a204251c3d14cfead66ed710c9ddf056f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a204251c3d14cfead66ed710c9ddf056f">&#9670;&nbsp;</a></span>FillupHoles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::FillupHoles </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AbstractPolygonTriangulator &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aBorders</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aFailed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an overloaded method provided for convenience. It takes as first argument the boundaries which must be filled up. </p>

</div>
</div>
<a id="a5112506f115411782270df607b1136c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5112506f115411782270df607b1136c7">&#9670;&nbsp;</a></span>FindComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::FindComponents </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>aInds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find topologic independent components with maximum <em>count</em> facets and returns an array of the indices. </p>

</div>
</div>
<a id="a2bf27d1d45c8025fcd25e1df3b57c809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf27d1d45c8025fcd25e1df3b57c809">&#9670;&nbsp;</a></span>FindHoles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::FindHoles </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; std::vector&lt; unsigned long &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>aBorders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find holes which consists of up to <em>length</em> edges. </p>

</div>
</div>
<a id="a60c3c802310a289b38911cb059406e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60c3c802310a289b38911cb059406e68">&#9670;&nbsp;</a></span>FlipNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::FlipNormals </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flips the normals. </p>

</div>
</div>
<a id="a0e11605db3f088012c3cf1476b0d3815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e11605db3f088012c3cf1476b0d3815">&#9670;&nbsp;</a></span>HarmonizeNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::HarmonizeNormals </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Harmonizes the normals. </p>

</div>
</div>
<a id="a2f70c92bb105665a849192cc1cbcf5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f70c92bb105665a849192cc1cbcf5e1">&#9670;&nbsp;</a></span>InsertVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::InsertVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a new vertex in the given triangle so that is split into three triangles. The given point must lie inside the triangle not outside or on an edge. </p>

</div>
</div>
<a id="a1c287376020e6acc00ef1988c579fef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c287376020e6acc00ef1988c579fef2">&#9670;&nbsp;</a></span>InsertVertexAndSwapEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::InsertVertexAndSwapEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMaxAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is provided for convenience. It inserts a new vertex to the mesh and tries to swap the common edges of the newly created facets with their neighbours. Just inserting a new vertex leads to very acute-angled triangles which might be problematic for some algorithms. This method tries to swap the edges to build more well-formed triangles. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a2f70c92bb105665a849192cc1cbcf5e1">InsertVertex()</a>, <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#ac92250229e3717d4c991959f2285b8b2">ShouldSwapEdge()</a>, <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#ab2be6ae8beacbda2efbbd7ed6103b9b6">SwapEdge()</a>. </dd></dl>

</div>
</div>
<a id="abb2f3fb67d722dcf9511b77ae42bf000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2f3fb67d722dcf9511b77ae42bf000">&#9670;&nbsp;</a></span>IsCollapseEdgeLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::IsCollapseEdgeLegal </td>
          <td>(</td>
          <td class="paramtype">const EdgeCollapse &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a collapse edge operation is legal, that is fulfilled if none of the adjacent facets flips its normal. If this operation is legal true is returned, false is returned if this operation is illegal. </p>

</div>
</div>
<a id="ac8c03ccd7df55dd64179eceffce010f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8c03ccd7df55dd64179eceffce010f5">&#9670;&nbsp;</a></span>IsSwapEdgeLegal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::IsSwapEdgeLegal </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulNeighbour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether a swap edge operation is legal, that is fulfilled if the two adjacent facets builds a convex polygon. If this operation is legal true is returned, false is returned if this operation is illegal or if <em>ulFacetPos</em> and <em>ulNeighbour</em> are not adjacent facets. </p>

</div>
</div>
<a id="a5b66e3d48bad86154ae237197a1d44e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b66e3d48bad86154ae237197a1d44e4">&#9670;&nbsp;</a></span>OptimizeTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::OptimizeTopology </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMaxAngle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to make a more beautiful mesh by swapping the common edge of two adjacent facets where needed. <em>fMaxAngle</em> is the maximum allowed angle between the normals of two adjacent facets to allow swapping the common edge. A too high value might result into folds on the surface. </p><dl class="section note"><dt>Note</dt><dd>This is a high-level operation and tries to optimize the mesh as a whole. </dd></dl>

</div>
</div>
<a id="a4d4b71df73a74b8c6a5ebeb984d69e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4b71df73a74b8c6a5ebeb984d69e44">&#9670;&nbsp;</a></span>RemoveComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::RemoveComponents </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes topologic independent components with maximum <em>count</em> facets. </p>

</div>
</div>
<a id="a70953cbcff9599205fe7b497fc47086a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70953cbcff9599205fe7b497fc47086a">&#9670;&nbsp;</a></span>RemoveCorruptedFacet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::RemoveCorruptedFacet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the corrupted facet at position <em>index</em> from the mesh structure. A facet is corrupted if the indices of its corner points are not all different. </p>

</div>
</div>
<a id="a3b08bfd54d2559608d4b113a14c0cbbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b08bfd54d2559608d4b113a14c0cbbb">&#9670;&nbsp;</a></span>RemoveDegeneratedFacet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::RemoveDegeneratedFacet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the degenerated facet at position <em>index</em> from the mesh structure. A facet is degenerated if its corner points are collinear. </p>

</div>
</div>
<a id="ac92250229e3717d4c991959f2285b8b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92250229e3717d4c991959f2285b8b2">&#9670;&nbsp;</a></span>ShouldSwapEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::ShouldSwapEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulNeighbour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fMaxAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the swap edge operation is legal and whether it makes sense. This operation only makes sense if the maximum angle of both facets is decreased and if the angle between the facet normals does not exceed <em>fMaxAngle</em>. </p>

</div>
</div>
<a id="a0690aa64132bdc71e2420d2fe9af2de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0690aa64132bdc71e2420d2fe9af2de0">&#9670;&nbsp;</a></span>SnapVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::SnapVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new triangle with neighbour facet <em>ulFacetPos</em> and the vertex <em>rclPoint</em> whereat it must lie outside the given facet. </p><dl class="section note"><dt>Note</dt><dd>The vertex <em>rclPoint</em> doesn't necessarily need to be a new vertex it can already be part of another triangle but the client programmer must make sure that no overlaps are created. </dd>
<dd>
This operation might be useful to close gaps in a mesh. </dd></dl>

</div>
</div>
<a id="aaa674e256ecfb87ba13bdfdfb8c8934a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa674e256ecfb87ba13bdfdfb8c8934a">&#9670;&nbsp;</a></span>SplitEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshTopoAlgorithm::SplitEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulNeighbour</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits the common edge of the two adjacent facets with index <em>ulFacetPos</em> and <em>ulNeighbour</em>. The point <em>rP</em> must lie inside of one the given facets are on the common edge. The two facets get broken into four facets, i.e. that two new facets get created. If <em>rP</em> is coincident with a corner point nothing happens. </p>

</div>
</div>
<a id="a7935625a21652cdf9b034019a6c8d940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7935625a21652cdf9b034019a6c8d940">&#9670;&nbsp;</a></span>SplitFacet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::SplitFacet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rP2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits the facet with index <em>ulFacetPos</em> into up to three facets. The points <em>rP1</em> and <em>rP2</em> should lie on two different edges of the facet. This method splits up the both neighbour facets as well. If either <em>rP1</em> or <em>rP2</em> (probably due to a previous call of <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#a7935625a21652cdf9b034019a6c8d940">SplitFacet()</a>) is coincident with a corner point then the facet is split into two facets. If both points are coincident with corner points of this facet nothing is done. </p>

</div>
</div>
<a id="a82f9d2b609339619cf45d48c727e5d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f9d2b609339619cf45d48c727e5d31">&#9670;&nbsp;</a></span>SplitOpenEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::SplitOpenEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>uSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rP</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Splits the facet with index <em>ulFacetPos</em> on the edge side <em>uSide</em> into two facets. This side must be an open edge otherwise nothing is done. The point <em>rP</em> must be near to this edge and must not be coincident with any corner vertices of the facet. </p>

</div>
</div>
<a id="ab2be6ae8beacbda2efbbd7ed6103b9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2be6ae8beacbda2efbbd7ed6103b9b6">&#9670;&nbsp;</a></span>SwapEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshTopoAlgorithm::SwapEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetPos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulNeighbour</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the common edge of two adjacent facets even if the operation might be illegal. To be sure that this operation is legal, check either with <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#ac8c03ccd7df55dd64179eceffce010f5">IsSwapEdgeLegal()</a> or <a class="el" href="classMeshCore_1_1MeshTopoAlgorithm.html#ac92250229e3717d4c991959f2285b8b2">ShouldSwapEdge()</a> before. An illegal swap edge operation can produce non-manifolds, degenerated facets or it might create a fold on the surface, i.e. geometric overlaps of several triangles. </p>

</div>
</div>
<a id="a9c146383a145b5639df13c3e711f8821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c146383a145b5639df13c3e711f8821">&#9670;&nbsp;</a></span>SwapEdgeBenefit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MeshCore::MeshTopoAlgorithm::SwapEdgeBenefit </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes a value for the benefit of swapping the edge. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jun 27 2019 00:32:46 for FreeCAD by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
