<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeCAD C++: MeshCore::MeshKernel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="width.css" rel="stylesheet" type="text/css"/>
<link href="details.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeCAD C++
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MeshCore</b></li><li class="navelem"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMeshCore_1_1MeshKernel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MeshCore::MeshKernel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;Mod/Mesh/App/Core/MeshKernel.h&gt;</code></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> class is the basic class that holds the data points, the edges and the facets describing a mesh object.</p>
<p>The bounding box is calculated during the buildup of the data structure and gets only re-caclulated after insertion of new facets but not after removal of facets.</p>
<p>This class provides only some rudimental querying methods. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a669609361223a81b762115276bb0919a"><td class="memItemLeft" align="right" valign="top"><a id="a669609361223a81b762115276bb0919a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a669609361223a81b762115276bb0919a">MeshKernel</a> (void)</td></tr>
<tr class="memdesc:a669609361223a81b762115276bb0919a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction. <br /></td></tr>
<tr class="separator:a669609361223a81b762115276bb0919a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b04039b5c33305438b454b0cfc2638"><td class="memItemLeft" align="right" valign="top"><a id="ab6b04039b5c33305438b454b0cfc2638"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ab6b04039b5c33305438b454b0cfc2638">MeshKernel</a> (const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;rclMesh)</td></tr>
<tr class="memdesc:ab6b04039b5c33305438b454b0cfc2638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construction. <br /></td></tr>
<tr class="separator:ab6b04039b5c33305438b454b0cfc2638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c252fe2b5592857c4fe234ed8f4280a"><td class="memItemLeft" align="right" valign="top"><a id="a1c252fe2b5592857c4fe234ed8f4280a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a1c252fe2b5592857c4fe234ed8f4280a">~MeshKernel</a> (void)</td></tr>
<tr class="memdesc:a1c252fe2b5592857c4fe234ed8f4280a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruction. <br /></td></tr>
<tr class="separator:a1c252fe2b5592857c4fe234ed8f4280a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">I/O methods</div></td></tr>
<tr class="memitem:a849b94fad505e86e703e225697657344"><td class="memItemLeft" align="right" valign="top"><a id="a849b94fad505e86e703e225697657344"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a849b94fad505e86e703e225697657344">Write</a> (std::ostream &amp;rclOut) const</td></tr>
<tr class="memdesc:a849b94fad505e86e703e225697657344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary streaming of data. <br /></td></tr>
<tr class="separator:a849b94fad505e86e703e225697657344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433d5a2541298b2b4dd096824a27944e"><td class="memItemLeft" align="right" valign="top"><a id="a433d5a2541298b2b4dd096824a27944e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Read</b> (std::istream &amp;rclIn)</td></tr>
<tr class="separator:a433d5a2541298b2b4dd096824a27944e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying</div></td></tr>
<tr class="memitem:a287530307c7041abc0b6b5432a1faa59"><td class="memItemLeft" align="right" valign="top"><a id="a287530307c7041abc0b6b5432a1faa59"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a287530307c7041abc0b6b5432a1faa59">CountFacets</a> (void) const</td></tr>
<tr class="memdesc:a287530307c7041abc0b6b5432a1faa59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of facets. <br /></td></tr>
<tr class="separator:a287530307c7041abc0b6b5432a1faa59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18536a6e7d6f45d16144c406fc5daf44"><td class="memItemLeft" align="right" valign="top"><a id="a18536a6e7d6f45d16144c406fc5daf44"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a18536a6e7d6f45d16144c406fc5daf44">CountEdges</a> (void) const</td></tr>
<tr class="memdesc:a18536a6e7d6f45d16144c406fc5daf44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of edge. <br /></td></tr>
<tr class="separator:a18536a6e7d6f45d16144c406fc5daf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d147577d568aeff6fc931530abdf29"><td class="memItemLeft" align="right" valign="top"><a id="a14d147577d568aeff6fc931530abdf29"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>CountPoints</b> (void) const</td></tr>
<tr class="separator:a14d147577d568aeff6fc931530abdf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31982e66b4a4b022b1a49c536b5ac2ab"><td class="memItemLeft" align="right" valign="top"><a id="a31982e66b4a4b022b1a49c536b5ac2ab"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a31982e66b4a4b022b1a49c536b5ac2ab">GetMemSize</a> (void) const</td></tr>
<tr class="memdesc:a31982e66b4a4b022b1a49c536b5ac2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of required memory in bytes. <br /></td></tr>
<tr class="separator:a31982e66b4a4b022b1a49c536b5ac2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b314b4fef04b792f098d3f6a3ebe0b2"><td class="memItemLeft" align="right" valign="top"><a id="a0b314b4fef04b792f098d3f6a3ebe0b2"></a>
const <a class="el" href="classBase_1_1BoundBox3.html">Base::BoundBox3f</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a0b314b4fef04b792f098d3f6a3ebe0b2">GetBoundBox</a> (void) const</td></tr>
<tr class="memdesc:a0b314b4fef04b792f098d3f6a3ebe0b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines the bounding box. <br /></td></tr>
<tr class="separator:a0b314b4fef04b792f098d3f6a3ebe0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80ca95e8c52a2057048df4579f8d67f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ac80ca95e8c52a2057048df4579f8d67f">RecalcBoundBox</a> (void)</td></tr>
<tr class="separator:ac80ca95e8c52a2057048df4579f8d67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463532eb2e61a8b2e6d5653bc549b6eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshPoint.html">MeshPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a463532eb2e61a8b2e6d5653bc549b6eb">GetPoint</a> (unsigned long ulIndex) const</td></tr>
<tr class="separator:a463532eb2e61a8b2e6d5653bc549b6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f10c873a3d89122aded52c2bce2bf7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ad9f10c873a3d89122aded52c2bce2bf7">CalcVertexNormals</a> () const</td></tr>
<tr class="separator:ad9f10c873a3d89122aded52c2bce2bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698337baa82e3ab1f319e640782672b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a698337baa82e3ab1f319e640782672b4">GetFacet</a> (unsigned long ulIndex) const</td></tr>
<tr class="separator:a698337baa82e3ab1f319e640782672b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fbb08b68f645c00d1a13ade6554063"><td class="memItemLeft" align="right" valign="top"><a id="ac3fbb08b68f645c00d1a13ade6554063"></a>
<a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a>&#160;</td><td class="memItemRight" valign="bottom"><b>GetFacet</b> (const <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &amp;rclFacet) const</td></tr>
<tr class="separator:ac3fbb08b68f645c00d1a13ade6554063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61849a6cd065479f04f535381c91814c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a61849a6cd065479f04f535381c91814c">GetFacetPoints</a> (unsigned long ulFaIndex, unsigned long &amp;rclP0, unsigned long &amp;rclP1, unsigned long &amp;rclP2) const</td></tr>
<tr class="separator:a61849a6cd065479f04f535381c91814c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6210616ee5171593a6846e9a052d97ca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a6210616ee5171593a6846e9a052d97ca">GetFacetPoints</a> (const std::vector&lt; unsigned long &gt; &amp;) const</td></tr>
<tr class="separator:a6210616ee5171593a6846e9a052d97ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84d874017c6e3761e3c3aa00d4d1617"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ac84d874017c6e3761e3c3aa00d4d1617">GetFacetNeighbours</a> (unsigned long ulIndex, unsigned long &amp;rulNIdx0, unsigned long &amp;rulNIdx1, unsigned long &amp;rulNIdx2) const</td></tr>
<tr class="separator:ac84d874017c6e3761e3c3aa00d4d1617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd21f7d89fec583012aa64843790c3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#abcd21f7d89fec583012aa64843790c3d">HasFacets</a> (const <a class="el" href="classMeshCore_1_1MeshPointIterator.html">MeshPointIterator</a> &amp;rclIter) const</td></tr>
<tr class="separator:abcd21f7d89fec583012aa64843790c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b08095948e42b0bc4358638a5cd84b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a9b08095948e42b0bc4358638a5cd84b1">IsValid</a> (void) const</td></tr>
<tr class="separator:a9b08095948e42b0bc4358638a5cd84b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035bc44ed03f94377ebca4885b90702b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a035bc44ed03f94377ebca4885b90702b">GetPoints</a> (void) const</td></tr>
<tr class="separator:a035bc44ed03f94377ebca4885b90702b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5e75d610a42791556321080584e2dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#afa5e75d610a42791556321080584e2dd">GetPoints</a> (const std::vector&lt; unsigned long &gt; &amp;) const</td></tr>
<tr class="separator:afa5e75d610a42791556321080584e2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e0b87905eea902f489e42f9de2c10f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshPointModifier.html">MeshPointModifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ac8e0b87905eea902f489e42f9de2c10f">ModifyPoints</a> ()</td></tr>
<tr class="separator:ac8e0b87905eea902f489e42f9de2c10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661febeb8d73940271dc21696ada0a7c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a661febeb8d73940271dc21696ada0a7c">GetFacets</a> (void) const</td></tr>
<tr class="separator:a661febeb8d73940271dc21696ada0a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af75e4b705d4ded83c7cad89aebad07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a5af75e4b705d4ded83c7cad89aebad07">GetFacets</a> (const std::vector&lt; unsigned long &gt; &amp;) const</td></tr>
<tr class="separator:a5af75e4b705d4ded83c7cad89aebad07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1017d7669925b8661cbdd6fb7ddf8c6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshFacetModifier.html">MeshFacetModifier</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a1017d7669925b8661cbdd6fb7ddf8c6d">ModifyFacets</a> ()</td></tr>
<tr class="separator:a1017d7669925b8661cbdd6fb7ddf8c6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272459d17aa6c512db4a10396a6a5a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a272459d17aa6c512db4a10396a6a5a3c">GetEdges</a> (std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomEdge.html">MeshGeomEdge</a> &gt; &amp;) const</td></tr>
<tr class="separator:a272459d17aa6c512db4a10396a6a5a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Evaluation</div></td></tr>
<tr class="memitem:a168b177b70dfee7cb0f45091ea5e3308"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a168b177b70dfee7cb0f45091ea5e3308">GetSurface</a> () const</td></tr>
<tr class="separator:a168b177b70dfee7cb0f45091ea5e3308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9674f74ed1bc9a79f0a9b434182d8046"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a9674f74ed1bc9a79f0a9b434182d8046">GetSurface</a> (const std::vector&lt; unsigned long &gt; &amp;aSegment) const</td></tr>
<tr class="separator:a9674f74ed1bc9a79f0a9b434182d8046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a9b2063a3f3b7e743f7b14db4956c7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a39a9b2063a3f3b7e743f7b14db4956c7">GetVolume</a> () const</td></tr>
<tr class="separator:a39a9b2063a3f3b7e743f7b14db4956c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d5aad84531e6800eb2d890b2021832"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a69d5aad84531e6800eb2d890b2021832">HasOpenEdges</a> () const</td></tr>
<tr class="separator:a69d5aad84531e6800eb2d890b2021832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecaa03ecc50e34f98b2d1606811d7d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#aeecaa03ecc50e34f98b2d1606811d7d4">HasNonManifolds</a> () const</td></tr>
<tr class="separator:aeecaa03ecc50e34f98b2d1606811d7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af87279a93e385be5e9bf061bcb344b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a5af87279a93e385be5e9bf061bcb344b">HasSelfIntersections</a> () const</td></tr>
<tr class="separator:a5af87279a93e385be5e9bf061bcb344b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Facet visitors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> class provides different methods to visit "topologic connected" facets to a given start facet. Two facets are regarded as "topologic connected" if they share a common edge or a common point. All methods expect a <a class="el" href="classMeshCore_1_1MeshFacetVisitor.html">MeshFacetVisitor</a> as argument that can decide to continue or to stop. If there is no topologic neighbour facet any more being not marked as "VISIT" the algorithm stops anyway. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classMeshCore_1_1MeshFacetVisitor.html">MeshFacetVisitor</a>, <a class="el" href="classMeshCore_1_1MeshOrientationVisitor.html">MeshOrientationVisitor</a>, <a class="el" href="classMeshCore_1_1MeshSearchNeighbourFacetsVisitor.html">MeshSearchNeighbourFacetsVisitor</a> and <a class="el" href="classMeshCore_1_1MeshTopFacetVisitor.html">MeshTopFacetVisitor</a>. </dd></dl>
</div></td></tr>
<tr class="memitem:aa6dc7ed83ab318e5e0455ea3a600688b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#aa6dc7ed83ab318e5e0455ea3a600688b">VisitNeighbourFacets</a> (<a class="el" href="classMeshCore_1_1MeshFacetVisitor.html">MeshFacetVisitor</a> &amp;rclFVisitor, unsigned long ulStartFacet) const</td></tr>
<tr class="separator:aa6dc7ed83ab318e5e0455ea3a600688b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627b2a72b7ce3c644f32a05f6b8ac5d9"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a627b2a72b7ce3c644f32a05f6b8ac5d9">VisitNeighbourFacetsOverCorners</a> (<a class="el" href="classMeshCore_1_1MeshFacetVisitor.html">MeshFacetVisitor</a> &amp;rclFVisitor, unsigned long ulStartFacet) const</td></tr>
<tr class="separator:a627b2a72b7ce3c644f32a05f6b8ac5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Point visitors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> class provides a method to visit neighbour points to a given start point. Two points are regarded as neighbours if they share an edge. The method expects a <a class="el" href="classMeshCore_1_1MeshPointVisitor.html">MeshPointVisitor</a> as argument that can decide to continue or to stop. If there is no topologic neighbour point any more being not marked as "VISIT" the algorithm stops anyway. </p>
</div></td></tr>
<tr class="memitem:ac6a54337416177caefb3015d5a50fd67"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ac6a54337416177caefb3015d5a50fd67">VisitNeighbourPoints</a> (<a class="el" href="classMeshCore_1_1MeshPointVisitor.html">MeshPointVisitor</a> &amp;rclPVisitor, unsigned long ulStartPoint) const</td></tr>
<tr class="separator:ac6a54337416177caefb3015d5a50fd67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterators</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The iterator methods are provided for convenience. They return an iterator object that points to the first element in the appropriate list. </p><div class="fragment"><div class="line"><a class="code" href="classMeshCore_1_1MeshKernel.html#a669609361223a81b762115276bb0919a">MeshKernel</a> mesh = ...</div><div class="line"><span class="comment">// iterate over all facets</span></div><div class="line">for ( MeshFacetIterator it = mesh.FacetIterator(); it.More(); it.Next() )</div><div class="line">...</div></div><!-- fragment --><p> An iterator can also be used in the following way </p><div class="fragment"><div class="line"><a class="code" href="classMeshCore_1_1MeshKernel.html#a669609361223a81b762115276bb0919a">MeshKernel</a> mesh = ...</div><div class="line"><span class="comment">// iterate over all facets</span></div><div class="line">MeshFacetIterator it(mesh);</div><div class="line"><span class="keywordflow">for</span> (  it.Init(); it.More(); it.Next() )</div><div class="line">...</div></div><!-- fragment --> </div></td></tr>
<tr class="memitem:a8e0367f8c59230ab499cac6df20bc439"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshFacetIterator.html">MeshFacetIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a8e0367f8c59230ab499cac6df20bc439">FacetIterator</a> () const</td></tr>
<tr class="separator:a8e0367f8c59230ab499cac6df20bc439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af46ed26af49026567af8e9197f87d60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshPointIterator.html">MeshPointIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#af46ed26af49026567af8e9197f87d60d">PointIterator</a> () const</td></tr>
<tr class="separator:af46ed26af49026567af8e9197f87d60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modification</div></td></tr>
<tr class="memitem:ad168fbab4c96eb991470d5a5c34f0547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ad168fbab4c96eb991470d5a5c34f0547">operator+=</a> (const <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &amp;rclSFacet)</td></tr>
<tr class="separator:ad168fbab4c96eb991470d5a5c34f0547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883c5825972e18bbb1f92a773d0190eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a883c5825972e18bbb1f92a773d0190eb">AddFacet</a> (const <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &amp;rclSFacet)</td></tr>
<tr class="separator:a883c5825972e18bbb1f92a773d0190eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ff5304119a6ffaebc4bc5f96858ecd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ad3ff5304119a6ffaebc4bc5f96858ecd">operator+=</a> (const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &gt; &amp;rclFAry)</td></tr>
<tr class="separator:ad3ff5304119a6ffaebc4bc5f96858ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a28b5a804c172050e5439c98a5061ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a5a28b5a804c172050e5439c98a5061ae">AddFacets</a> (const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &gt; &amp;rclFAry)</td></tr>
<tr class="separator:a5a28b5a804c172050e5439c98a5061ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4cf6750abbb5f50c217ec18b249182b"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ae4cf6750abbb5f50c217ec18b249182b">AddFacets</a> (const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &gt; &amp;rclFAry, bool checkManifolds)</td></tr>
<tr class="separator:ae4cf6750abbb5f50c217ec18b249182b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab589ca9f27307bc1aaf0f5cd0eb2797"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#aab589ca9f27307bc1aaf0f5cd0eb2797">AddFacets</a> (const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &gt; &amp;rclFAry, const std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;rclPAry, bool checkManifolds)</td></tr>
<tr class="separator:aab589ca9f27307bc1aaf0f5cd0eb2797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8652dd465098e95e186061728e4665f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a8652dd465098e95e186061728e4665f9">Merge</a> (const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;rKernel)</td></tr>
<tr class="separator:a8652dd465098e95e186061728e4665f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13eb81ded9366a083f14bd91bea0f3ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a13eb81ded9366a083f14bd91bea0f3ae">Merge</a> (const <a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;rPoints, const <a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;rFaces)</td></tr>
<tr class="separator:a13eb81ded9366a083f14bd91bea0f3ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0ca9215e7fc4adb605f6bd7a64f174"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a6c0ca9215e7fc4adb605f6bd7a64f174">DeleteFacet</a> (const <a class="el" href="classMeshCore_1_1MeshFacetIterator.html">MeshFacetIterator</a> &amp;rclIter)</td></tr>
<tr class="separator:a6c0ca9215e7fc4adb605f6bd7a64f174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606f3feb15175946c32a0967e2f8eaaf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a606f3feb15175946c32a0967e2f8eaaf">DeleteFacet</a> (unsigned long ulInd)</td></tr>
<tr class="separator:a606f3feb15175946c32a0967e2f8eaaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51560a25abaecf14237e4cfd0b6995af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a51560a25abaecf14237e4cfd0b6995af">DeleteFacets</a> (const std::vector&lt; unsigned long &gt; &amp;raulFacets)</td></tr>
<tr class="separator:a51560a25abaecf14237e4cfd0b6995af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21e3c2f5ae4fa32b1b9a345273328f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#aae21e3c2f5ae4fa32b1b9a345273328f">DeletePoint</a> (const <a class="el" href="classMeshCore_1_1MeshPointIterator.html">MeshPointIterator</a> &amp;rclIter)</td></tr>
<tr class="separator:aae21e3c2f5ae4fa32b1b9a345273328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a489a14695d3b5d509553e48680c4c81d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a489a14695d3b5d509553e48680c4c81d">DeletePoint</a> (unsigned long ulInd)</td></tr>
<tr class="separator:a489a14695d3b5d509553e48680c4c81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e29866179c8579f078b7824b40219d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ac6e29866179c8579f078b7824b40219d">DeletePoints</a> (const std::vector&lt; unsigned long &gt; &amp;raulPoints)</td></tr>
<tr class="separator:ac6e29866179c8579f078b7824b40219d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d396749015c4e75cc5a09e1b790a306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a3d396749015c4e75cc5a09e1b790a306">RemoveInvalids</a> ()</td></tr>
<tr class="separator:a3d396749015c4e75cc5a09e1b790a306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f38a8536610640818e494ff74a4a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#afe7f38a8536610640818e494ff74a4a3">RebuildNeighbours</a> (void)</td></tr>
<tr class="separator:afe7f38a8536610640818e494ff74a4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6b59ce3baa767e991adde371fdeeb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#adf6b59ce3baa767e991adde371fdeeb4">Cleanup</a> ()</td></tr>
<tr class="separator:adf6b59ce3baa767e991adde371fdeeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5df302d4044c5995e4acf224362247"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a3a5df302d4044c5995e4acf224362247">Clear</a> (void)</td></tr>
<tr class="separator:a3a5df302d4044c5995e4acf224362247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa419ed546cb3fe58b61a18bd55dea5e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#aa419ed546cb3fe58b61a18bd55dea5e8">operator=</a> (const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &gt; &amp;rclFAry)</td></tr>
<tr class="separator:aa419ed546cb3fe58b61a18bd55dea5e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa187cfc76d1068f8069be2afb5045e33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#aa187cfc76d1068f8069be2afb5045e33">operator=</a> (const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;rclMesh)</td></tr>
<tr class="separator:aa187cfc76d1068f8069be2afb5045e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838b62fdf80eb4208d72824f17495afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a838b62fdf80eb4208d72824f17495afe">Assign</a> (const <a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;rPoints, const <a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;rFaces, bool checkNeighbourHood=false)</td></tr>
<tr class="separator:a838b62fdf80eb4208d72824f17495afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b0754f98cee058449f6fd8f30e028a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#ae0b0754f98cee058449f6fd8f30e028a">Adopt</a> (<a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;rPoints, <a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;rFaces, bool checkNeighbourHood=false)</td></tr>
<tr class="separator:ae0b0754f98cee058449f6fd8f30e028a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b774c9f6c040f638daf7f9c49ffe668"><td class="memItemLeft" align="right" valign="top"><a id="a0b774c9f6c040f638daf7f9c49ffe668"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a0b774c9f6c040f638daf7f9c49ffe668">Swap</a> (<a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;mesh)</td></tr>
<tr class="memdesc:a0b774c9f6c040f638daf7f9c49ffe668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the content of this kernel and <em>mesh</em>. <br /></td></tr>
<tr class="separator:a0b774c9f6c040f638daf7f9c49ffe668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5641edf891a109dc4c594c2b2c520c6a"><td class="memItemLeft" align="right" valign="top"><a id="a5641edf891a109dc4c594c2b2c520c6a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a5641edf891a109dc4c594c2b2c520c6a">operator *=</a> (const <a class="el" href="classBase_1_1Matrix4D.html">Base::Matrix4D</a> &amp;rclMat)</td></tr>
<tr class="memdesc:a5641edf891a109dc4c594c2b2c520c6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the data structure with the given transformation matrix. <br /></td></tr>
<tr class="separator:a5641edf891a109dc4c594c2b2c520c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19c4c9f88404bcfe2ddd1642fc7f4bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#af19c4c9f88404bcfe2ddd1642fc7f4bc">Transform</a> (const <a class="el" href="classBase_1_1Matrix4D.html">Base::Matrix4D</a> &amp;rclMat)</td></tr>
<tr class="separator:af19c4c9f88404bcfe2ddd1642fc7f4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb60b6f8352cdae56cd40103a29ce13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a3bb60b6f8352cdae56cd40103a29ce13">MovePoint</a> (unsigned long ulPtIndex, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclTrans)</td></tr>
<tr class="separator:a3bb60b6f8352cdae56cd40103a29ce13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cad853d218591c190421fa59a3fce66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a3cad853d218591c190421fa59a3fce66">SetPoint</a> (unsigned long ulPtIndex, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rPoint)</td></tr>
<tr class="separator:a3cad853d218591c190421fa59a3fce66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790ddc78184b8e2e62887a06e33c048a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a790ddc78184b8e2e62887a06e33c048a">SetPoint</a> (unsigned long ulPtIndex, float x, float y, float z)</td></tr>
<tr class="separator:a790ddc78184b8e2e62887a06e33c048a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfc4f8a9f8ca5f376e76ac2e6f9e55d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a4bfc4f8a9f8ca5f376e76ac2e6f9e55d">Smooth</a> (int iterations, float d_max)</td></tr>
<tr class="separator:a4bfc4f8a9f8ca5f376e76ac2e6f9e55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca448c4d53349946195e3d0ce8c4cf0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#aca448c4d53349946195e3d0ce8c4cf0b">CutFacets</a> (const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, const <a class="el" href="classBase_1_1ViewProjMethod.html">Base::ViewProjMethod</a> *pclP, const <a class="el" href="classBase_1_1Polygon2d.html">Base::Polygon2d</a> &amp;rclPoly, bool bCutInner, std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &gt; &amp;raclFacets)</td></tr>
<tr class="separator:aca448c4d53349946195e3d0ce8c4cf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83293381912355b8863f2b6998e40da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a83293381912355b8863f2b6998e40da3">CutFacets</a> (const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;rclGrid, const <a class="el" href="classBase_1_1ViewProjMethod.html">Base::ViewProjMethod</a> *pclP, const <a class="el" href="classBase_1_1Polygon2d.html">Base::Polygon2d</a> &amp;rclPoly, bool bCutInner, std::vector&lt; unsigned long &gt; &amp;raclCutted)</td></tr>
<tr class="separator:a83293381912355b8863f2b6998e40da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a88bd87cc43aab9c672cb19b8f71205e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a88bd87cc43aab9c672cb19b8f71205e9">RebuildNeighbours</a> (unsigned long)</td></tr>
<tr class="separator:a88bd87cc43aab9c672cb19b8f71205e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f5e4e8ff00d79e15da4c28700654759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a2f5e4e8ff00d79e15da4c28700654759">ErasePoint</a> (unsigned long ulIndex, unsigned long ulFacetIndex, bool bOnlySetInvalid=false)</td></tr>
<tr class="separator:a2f5e4e8ff00d79e15da4c28700654759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f8c7dd8f4d1e6a645f3cf4d72a3acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#af2f8c7dd8f4d1e6a645f3cf4d72a3acc">AdjustNormal</a> (<a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &amp;rclFacet, const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;rclNormal)</td></tr>
<tr class="separator:af2f8c7dd8f4d1e6a645f3cf4d72a3acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899aefed5ca507614d6d0dbfabac5ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a899aefed5ca507614d6d0dbfabac5ed0">GetNormal</a> (const <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &amp;rclFacet) const</td></tr>
<tr class="separator:a899aefed5ca507614d6d0dbfabac5ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cce71449b9303e9e2509487f487b290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a0cce71449b9303e9e2509487f487b290">GetGravityPoint</a> (const <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &amp;rclFacet) const</td></tr>
<tr class="separator:a0cce71449b9303e9e2509487f487b290"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2510fa1fe417b92b9e8f68ac516b4105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a2510fa1fe417b92b9e8f68ac516b4105">_aclPointArray</a></td></tr>
<tr class="separator:a2510fa1fe417b92b9e8f68ac516b4105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c2436935a29ba0f7e971869d63c3ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a70c2436935a29ba0f7e971869d63c3ec">_aclFacetArray</a></td></tr>
<tr class="separator:a70c2436935a29ba0f7e971869d63c3ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3d9f6704dbe2fbeea38de27ebdcb72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBase_1_1BoundBox3.html">Base::BoundBox3f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a0a3d9f6704dbe2fbeea38de27ebdcb72">_clBoundBox</a></td></tr>
<tr class="separator:a0a3d9f6704dbe2fbeea38de27ebdcb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d473a8c2afb9da7215410619591a92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshCore_1_1MeshKernel.html#a95d473a8c2afb9da7215410619591a92">_bValid</a></td></tr>
<tr class="separator:a95d473a8c2afb9da7215410619591a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a883c5825972e18bbb1f92a773d0190eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883c5825972e18bbb1f92a773d0190eb">&#9670;&nbsp;</a></span>AddFacet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::AddFacet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &amp;&#160;</td>
          <td class="paramname"><em>rclSFacet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single facet to the data structure. This method is very slow and should be called occasionally only. This does the same as the += operator above. </p>

</div>
</div>
<a id="a5a28b5a804c172050e5439c98a5061ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a28b5a804c172050e5439c98a5061ae">&#9670;&nbsp;</a></span>AddFacets() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::AddFacets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclFAry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an array of facets to the data structure. This method keeps temporarily set properties and flags. This does the same as the += operator above. </p>

</div>
</div>
<a id="ae4cf6750abbb5f50c217ec18b249182b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4cf6750abbb5f50c217ec18b249182b">&#9670;&nbsp;</a></span>AddFacets() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MeshCore::MeshKernel::AddFacets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclFAry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkManifolds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an array of topologic facets to the data structure without inserting new points. Facets which would create non-manifolds are not inserted. The client programmer must make sure that the referenced point indices are correct and that no geometric overlaps can be created. The method returns the total number of facets. This method might be useful to close gaps or fill up holes in a mesh. </p><dl class="section note"><dt>Note</dt><dd>This method is quite expensive and should be rarely used. </dd></dl>

</div>
</div>
<a id="aab589ca9f27307bc1aaf0f5cd0eb2797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab589ca9f27307bc1aaf0f5cd0eb2797">&#9670;&nbsp;</a></span>AddFacets() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MeshCore::MeshKernel::AddFacets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclFAry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclPAry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkManifolds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds new points and facets to the data structure. The client programmer must make sure that all new points are referenced by the new facets. All points in <em>rclPAry</em> get copied at the end of the internal point array to keep their order. The point indices of the facets must be related to the internal point array, not the passed array <em>rclPAry</em>.</p>
<p>Example: We have a mesh with p points and f facets where we want append new points and facets to. Let's assume that the first facet of <em>rclFAry</em> references the 1st, 2nd and 3rd points of <em>rclPAry</em> then its indices must be p, p+1, p+2 &ndash; not 0,1,2. This is due to the fact that facets of <em>rclFAry</em> can also reference point indices of the internal point array. </p><dl class="section note"><dt>Note</dt><dd>This method is quite expensive and should be rarely used. </dd></dl>

</div>
</div>
<a id="af2f8c7dd8f4d1e6a645f3cf4d72a3acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f8c7dd8f4d1e6a645f3cf4d72a3acc">&#9670;&nbsp;</a></span>AdjustNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::AdjustNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &amp;&#160;</td>
          <td class="paramname"><em>rclFacet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclNormal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjusts the facet's orierntation to the given normal direction. </p>

</div>
</div>
<a id="ae0b0754f98cee058449f6fd8f30e028a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b0754f98cee058449f6fd8f30e028a">&#9670;&nbsp;</a></span>Adopt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::Adopt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkNeighbourHood</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method does basically the same as <a class="el" href="classMeshCore_1_1MeshKernel.html#a838b62fdf80eb4208d72824f17495afe">Assign()</a> unless that it swaps the content of both arrays. These arrays may be empty after assigning to the kernel. This method is a convenient way to build up the mesh structure from outside and assign to a mesh kernel without copying the data. Especially for huge meshes this saves memory and increases speed. </p>

</div>
</div>
<a id="a838b62fdf80eb4208d72824f17495afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a838b62fdf80eb4208d72824f17495afe">&#9670;&nbsp;</a></span>Assign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::Assign </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkNeighbourHood</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This allows to assign the mesh structure directly. The caller must make sure that the point indices are correctly set but the neighbourhood gets checked and corrected if <em>checkNeighbourHood</em> is true. </p>

</div>
</div>
<a id="ad9f10c873a3d89122aded52c2bce2bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f10c873a3d89122aded52c2bce2bf7">&#9670;&nbsp;</a></span>CalcVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a>&gt; MeshCore::MeshKernel::CalcVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array of the vertex normals of the mesh. A vertex normal gets calculated by summarizing the normals of the associated facets. </p>

</div>
</div>
<a id="adf6b59ce3baa767e991adde371fdeeb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6b59ce3baa767e991adde371fdeeb4">&#9670;&nbsp;</a></span>Cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::Cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes unreferenced points or facets with invalid indices from the mesh. </p>

</div>
</div>
<a id="a3a5df302d4044c5995e4acf224362247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5df302d4044c5995e4acf224362247">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::Clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the whole data structure. </p>

</div>
</div>
<a id="aca448c4d53349946195e3d0ce8c4cf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca448c4d53349946195e3d0ce8c4cf0b">&#9670;&nbsp;</a></span>CutFacets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::CutFacets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1ViewProjMethod.html">Base::ViewProjMethod</a> *&#160;</td>
          <td class="paramname"><em>pclP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Polygon2d.html">Base::Polygon2d</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCutInner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclFacets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>CheckFacets() is invoked within this method and all found facets get deleted from the mesh structure. The facets to be deleted are returned with their geometric representation. </p><dl class="section see"><dt>See also</dt><dd>CheckFacets(). </dd></dl>

</div>
</div>
<a id="a83293381912355b8863f2b6998e40da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83293381912355b8863f2b6998e40da3">&#9670;&nbsp;</a></span>CutFacets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::CutFacets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetGrid.html">MeshFacetGrid</a> &amp;&#160;</td>
          <td class="paramname"><em>rclGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1ViewProjMethod.html">Base::ViewProjMethod</a> *&#160;</td>
          <td class="paramname"><em>pclP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Polygon2d.html">Base::Polygon2d</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPoly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCutInner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raclCutted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does basically the same as method above unless that the facets to be deleted are returned with their index number in the facet array of the mesh structure. </p>

</div>
</div>
<a id="a6c0ca9215e7fc4adb605f6bd7a64f174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0ca9215e7fc4adb605f6bd7a64f174">&#9670;&nbsp;</a></span>DeleteFacet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::DeleteFacet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetIterator.html">MeshFacetIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rclIter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the facet the iterator points to. The deletion of a facet requires the following steps: </p><ul>
<li>Mark the neighbour index of all neighbour facets to the deleted facet as invalid </li>
<li>Adjust the indices of the neighbour facets of all facets. </li>
<li>If there is no neighbour facet check if the points can be deleted. True is returned if the facet could be deleted. <dl class="section note"><dt>Note</dt><dd>This method is very slow and should only be called occasionally. </dd>
<dd>
After deletion of the facet <em>rclIter</em> becomes invalid and must not be used before setting to a new position. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a606f3feb15175946c32a0967e2f8eaaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606f3feb15175946c32a0967e2f8eaaf">&#9670;&nbsp;</a></span>DeleteFacet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::DeleteFacet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulInd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does basically the same as the method above unless that the index of the facet is given. </p>

</div>
</div>
<a id="a51560a25abaecf14237e4cfd0b6995af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51560a25abaecf14237e4cfd0b6995af">&#9670;&nbsp;</a></span>DeleteFacets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::DeleteFacets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulFacets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes several facets from the data structure. </p><dl class="section note"><dt>Note</dt><dd>This method overwrites the free usable property of each mesh point. </dd>
<dd>
This method also removes points from the structure that are no longer referenced by the facets. </dd>
<dd>
This method is very slow and should only be called occasionally. </dd></dl>

</div>
</div>
<a id="aae21e3c2f5ae4fa32b1b9a345273328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21e3c2f5ae4fa32b1b9a345273328f">&#9670;&nbsp;</a></span>DeletePoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::DeletePoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshPointIterator.html">MeshPointIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rclIter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the point the iterator points to. The deletion of a point requires the following step: </p><ul>
<li>Find all associated facets to this point. </li>
<li>Delete these facets. True is returned if the point could be deleted. <dl class="section note"><dt>Note</dt><dd>This method is very slow and should only be called occasionally. </dd>
<dd>
After deletion of the point <em>rclIter</em> becomes invalid and must not be used before setting to a new position. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a489a14695d3b5d509553e48680c4c81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a489a14695d3b5d509553e48680c4c81d">&#9670;&nbsp;</a></span>DeletePoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::DeletePoint </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulInd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does basically the same as the method above unless that the index of the facet is given. </p>

</div>
</div>
<a id="ac6e29866179c8579f078b7824b40219d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e29866179c8579f078b7824b40219d">&#9670;&nbsp;</a></span>DeletePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::DeletePoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>raulPoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes several points from the data structure. </p><dl class="section note"><dt>Note</dt><dd>This method overwrites the free usable property of each mesh point. </dd></dl>

</div>
</div>
<a id="a2f5e4e8ff00d79e15da4c28700654759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f5e4e8ff00d79e15da4c28700654759">&#9670;&nbsp;</a></span>ErasePoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::ErasePoint </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFacetIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOnlySetInvalid</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Checks if this point is associated to no other facet and deletes if so. The point indices of the facets get adjusted. <em>ulIndex</em> is the index of the point to be deleted. <em>ulFacetIndex</em> is the index of the quasi deleted facet and is ignored. If <em>bOnlySetInvalid</em> is true the point doesn't get deleted but marked as invalid. </p>

</div>
</div>
<a id="a8e0367f8c59230ab499cac6df20bc439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0367f8c59230ab499cac6df20bc439">&#9670;&nbsp;</a></span>FacetIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshFacetIterator.html">MeshFacetIterator</a> MeshCore::MeshKernel::FacetIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator object to go over all facets. </p>

</div>
</div>
<a id="a272459d17aa6c512db4a10396a6a5a3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272459d17aa6c512db4a10396a6a5a3c">&#9670;&nbsp;</a></span>GetEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::GetEdges </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomEdge.html">MeshGeomEdge</a> &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the array of all edges. Notice: The Edgelist will be temporary generated. Changes on the mesh structure does not affect the Edgelist </p>

</div>
</div>
<a id="a698337baa82e3ab1f319e640782672b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698337baa82e3ab1f319e640782672b4">&#9670;&nbsp;</a></span>GetFacet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> MeshCore::MeshKernel::GetFacet </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the facet at the given index. This method is rather slow and should be called occasionally only. For fast access the <a class="el" href="classMeshCore_1_1MeshFacetIterator.html">MeshFacetIterator</a> interface should be used. </p>

</div>
</div>
<a id="ac84d874017c6e3761e3c3aa00d4d1617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84d874017c6e3761e3c3aa00d4d1617">&#9670;&nbsp;</a></span>GetFacetNeighbours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::GetFacetNeighbours </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulNIdx0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulNIdx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rulNIdx2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the indices of the neighbour facets of the given facet index. </p>

</div>
</div>
<a id="a61849a6cd065479f04f535381c91814c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61849a6cd065479f04f535381c91814c">&#9670;&nbsp;</a></span>GetFacetPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::GetFacetPoints </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulFaIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rclP0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rclP1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>rclP2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the point indices of the given facet index. </p>

</div>
</div>
<a id="a6210616ee5171593a6846e9a052d97ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6210616ee5171593a6846e9a052d97ca">&#9670;&nbsp;</a></span>GetFacetPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned long&gt; MeshCore::MeshKernel::GetFacetPoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the point indices of the given facet indices. </p>

</div>
</div>
<a id="a661febeb8d73940271dc21696ada0a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661febeb8d73940271dc21696ada0a7c">&#9670;&nbsp;</a></span>GetFacets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a>&amp; MeshCore::MeshKernel::GetFacets </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the array of all facets </p>

</div>
</div>
<a id="a5af75e4b705d4ded83c7cad89aebad07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af75e4b705d4ded83c7cad89aebad07">&#9670;&nbsp;</a></span>GetFacets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> MeshCore::MeshKernel::GetFacets </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array of facets to the given indices. The indices must not be out of range. </p>

</div>
</div>
<a id="a0cce71449b9303e9e2509487f487b290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cce71449b9303e9e2509487f487b290">&#9670;&nbsp;</a></span>GetGravityPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> MeshCore::MeshKernel::GetGravityPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &amp;&#160;</td>
          <td class="paramname"><em>rclFacet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the gravity point to the given facet. </p>

</div>
</div>
<a id="a899aefed5ca507614d6d0dbfabac5ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899aefed5ca507614d6d0dbfabac5ed0">&#9670;&nbsp;</a></span>GetNormal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> MeshCore::MeshKernel::GetNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacet.html">MeshFacet</a> &amp;&#160;</td>
          <td class="paramname"><em>rclFacet</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculates the normal to the given facet. </p>

</div>
</div>
<a id="a463532eb2e61a8b2e6d5653bc549b6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463532eb2e61a8b2e6d5653bc549b6eb">&#9670;&nbsp;</a></span>GetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshPoint.html">MeshPoint</a> MeshCore::MeshKernel::GetPoint </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the point at the given index. This method is rather slow and should be called occasionally only. For fast access the <a class="el" href="classMeshCore_1_1MeshPointIterator.html">MeshPointIterator</a> interfsce should be used. </p>

</div>
</div>
<a id="a035bc44ed03f94377ebca4885b90702b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035bc44ed03f94377ebca4885b90702b">&#9670;&nbsp;</a></span>GetPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a>&amp; MeshCore::MeshKernel::GetPoints </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the array of all data points. </p>

</div>
</div>
<a id="afa5e75d610a42791556321080584e2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa5e75d610a42791556321080584e2dd">&#9670;&nbsp;</a></span>GetPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> MeshCore::MeshKernel::GetPoints </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an array of points to the given indices. The indices must not be out of range. </p>

</div>
</div>
<a id="a168b177b70dfee7cb0f45091ea5e3308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168b177b70dfee7cb0f45091ea5e3308">&#9670;&nbsp;</a></span>GetSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MeshCore::MeshKernel::GetSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the surface area of the mesh object. </p>

</div>
</div>
<a id="a9674f74ed1bc9a79f0a9b434182d8046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9674f74ed1bc9a79f0a9b434182d8046">&#9670;&nbsp;</a></span>GetSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MeshCore::MeshKernel::GetSurface </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; unsigned long &gt; &amp;&#160;</td>
          <td class="paramname"><em>aSegment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the surface area of the segment defined by <em>aSegment</em>. </p>

</div>
</div>
<a id="a39a9b2063a3f3b7e743f7b14db4956c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39a9b2063a3f3b7e743f7b14db4956c7">&#9670;&nbsp;</a></span>GetVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MeshCore::MeshKernel::GetVolume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the volume of the mesh object. Therefore the mesh must be a solid, if not 0 is returned. </p>

</div>
</div>
<a id="abcd21f7d89fec583012aa64843790c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd21f7d89fec583012aa64843790c3d">&#9670;&nbsp;</a></span>HasFacets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned long&gt; MeshCore::MeshKernel::HasFacets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshPointIterator.html">MeshPointIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>rclIter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines all facets that are associated to this point. This method is very slow and should be called occasionally only. </p>

</div>
</div>
<a id="aeecaa03ecc50e34f98b2d1606811d7d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecaa03ecc50e34f98b2d1606811d7d4">&#9670;&nbsp;</a></span>HasNonManifolds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::HasNonManifolds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the mesh has non.manifold edges. An edge is regarded as non-manifolds if it shares more than two facets. </p>

</div>
</div>
<a id="a69d5aad84531e6800eb2d890b2021832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69d5aad84531e6800eb2d890b2021832">&#9670;&nbsp;</a></span>HasOpenEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::HasOpenEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the mesh has open edges. </p>

</div>
</div>
<a id="a5af87279a93e385be5e9bf061bcb344b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af87279a93e385be5e9bf061bcb344b">&#9670;&nbsp;</a></span>HasSelfIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::HasSelfIntersections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether the mesh intersects itself. </p>

</div>
</div>
<a id="a9b08095948e42b0bc4358638a5cd84b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b08095948e42b0bc4358638a5cd84b1">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::IsValid </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the data structure is valid. </p>

</div>
</div>
<a id="a8652dd465098e95e186061728e4665f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8652dd465098e95e186061728e4665f9">&#9670;&nbsp;</a></span>Merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td>
          <td class="paramname"><em>rKernel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds all facets and referenced points to the underlying mesh structure. The client programmer must be sure that both meshes don't have geometric overlaps, otherwise the resulting mesh might be invalid, i.e. has self-intersections. </p><dl class="section note"><dt>Note</dt><dd>The method guarantees that the order of the arrays of the underlying mesh and of the given array is kept. </dd>
<dd>
Not all points of <em>rKernel</em> are necessarily appended to the underlying mesh but only these points which are referenced by facets of <em>rKernel</em>. </dd></dl>

</div>
</div>
<a id="a13eb81ded9366a083f14bd91bea0f3ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13eb81ded9366a083f14bd91bea0f3ae">&#9670;&nbsp;</a></span>Merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::Merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> &amp;&#160;</td>
          <td class="paramname"><em>rFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is provided for convenience that directly accepts the point and facet arrays. </p><dl class="section note"><dt>Note</dt><dd>Not all points of <em>rPoints</em> are necessarily appended to the underlying mesh but only these points which are referenced by facets of <em>rFaces</em>. </dd></dl>

</div>
</div>
<a id="a1017d7669925b8661cbdd6fb7ddf8c6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1017d7669925b8661cbdd6fb7ddf8c6d">&#9670;&nbsp;</a></span>ModifyFacets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshFacetModifier.html">MeshFacetModifier</a> MeshCore::MeshKernel::ModifyFacets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a modifier for the facet array </p>

</div>
</div>
<a id="ac8e0b87905eea902f489e42f9de2c10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e0b87905eea902f489e42f9de2c10f">&#9670;&nbsp;</a></span>ModifyPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshPointModifier.html">MeshPointModifier</a> MeshCore::MeshKernel::ModifyPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a modifier for the point array </p>

</div>
</div>
<a id="a3bb60b6f8352cdae56cd40103a29ce13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb60b6f8352cdae56cd40103a29ce13">&#9670;&nbsp;</a></span>MovePoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::MovePoint </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rclTrans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Moves the point at the given index along the vector <em>rclTrans</em>. </p>

</div>
</div>
<a id="ad168fbab4c96eb991470d5a5c34f0547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad168fbab4c96eb991470d5a5c34f0547">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a>&amp; MeshCore::MeshKernel::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &amp;&#160;</td>
          <td class="paramname"><em>rclSFacet</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a single facet to the data structure. This method is very slow and should be called occasionally only. </p>

</div>
</div>
<a id="ad3ff5304119a6ffaebc4bc5f96858ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ff5304119a6ffaebc4bc5f96858ecd">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a>&amp; MeshCore::MeshKernel::operator+= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclFAry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds an array of facets to the data structure. This method keeps temporarily set properties and flags. </p>

</div>
</div>
<a id="aa419ed546cb3fe58b61a18bd55dea5e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa419ed546cb3fe58b61a18bd55dea5e8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a>&amp; MeshCore::MeshKernel::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classMeshCore_1_1MeshGeomFacet.html">MeshGeomFacet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rclFAry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the current data structure with the structure built up of the array of triangles given in <em>rclFAry</em>. </p>

</div>
</div>
<a id="aa187cfc76d1068f8069be2afb5045e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa187cfc76d1068f8069be2afb5045e33">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a>&amp; MeshCore::MeshKernel::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMeshCore_1_1MeshKernel.html">MeshKernel</a> &amp;&#160;</td>
          <td class="paramname"><em>rclMesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. </p>

</div>
</div>
<a id="af46ed26af49026567af8e9197f87d60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ed26af49026567af8e9197f87d60d">&#9670;&nbsp;</a></span>PointIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshPointIterator.html">MeshPointIterator</a> MeshCore::MeshKernel::PointIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an iterator object to go over all points. </p>

</div>
</div>
<a id="afe7f38a8536610640818e494ff74a4a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7f38a8536610640818e494ff74a4a3">&#9670;&nbsp;</a></span>RebuildNeighbours() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::RebuildNeighbours </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rebuilds the neighbour indices for all facets. </p>

</div>
</div>
<a id="a88bd87cc43aab9c672cb19b8f71205e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bd87cc43aab9c672cb19b8f71205e9">&#9670;&nbsp;</a></span>RebuildNeighbours() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::RebuildNeighbours </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rebuilds the neighbour indices for subset of all facets from index <em>index</em> on. </p>

</div>
</div>
<a id="ac80ca95e8c52a2057048df4579f8d67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80ca95e8c52a2057048df4579f8d67f">&#9670;&nbsp;</a></span>RecalcBoundBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::RecalcBoundBox </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces a recalculation of the bounding box. This method should be called after the removal of points.or after a transformation of the data structure. </p>

</div>
</div>
<a id="a3d396749015c4e75cc5a09e1b790a306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d396749015c4e75cc5a09e1b790a306">&#9670;&nbsp;</a></span>RemoveInvalids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::RemoveInvalids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all as INVALID marked points and facets from the structure. </p>

</div>
</div>
<a id="a3cad853d218591c190421fa59a3fce66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cad853d218591c190421fa59a3fce66">&#9670;&nbsp;</a></span>SetPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::SetPoint </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Vector3.html">Base::Vector3f</a> &amp;&#160;</td>
          <td class="paramname"><em>rPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the point at the given index to the new <em>rPoint</em>. </p>

</div>
</div>
<a id="a790ddc78184b8e2e62887a06e33c048a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790ddc78184b8e2e62887a06e33c048a">&#9670;&nbsp;</a></span>SetPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::SetPoint </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulPtIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the point at the given index to the new <em>rPoint</em>. </p>

</div>
</div>
<a id="a4bfc4f8a9f8ca5f376e76ac2e6f9e55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfc4f8a9f8ca5f376e76ac2e6f9e55d">&#9670;&nbsp;</a></span>Smooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::Smooth </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>d_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Smoothes the mesh kernel. </p>

</div>
</div>
<a id="af19c4c9f88404bcfe2ddd1642fc7f4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19c4c9f88404bcfe2ddd1642fc7f4bc">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MeshCore::MeshKernel::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBase_1_1Matrix4D.html">Base::Matrix4D</a> &amp;&#160;</td>
          <td class="paramname"><em>rclMat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transform the data structure with the given transformation matrix. It does exactly the same as the '*=' operator. </p>

</div>
</div>
<a id="aa6dc7ed83ab318e5e0455ea3a600688b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dc7ed83ab318e5e0455ea3a600688b">&#9670;&nbsp;</a></span>VisitNeighbourFacets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MeshCore::MeshKernel::VisitNeighbourFacets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMeshCore_1_1MeshFacetVisitor.html">MeshFacetVisitor</a> &amp;&#160;</td>
          <td class="paramname"><em>rclFVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulStartFacet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method visits all neighbour facets, i.e facets that share a common edge starting from the facet associated to index <em>ulStartFacet</em>. All facets having set the VISIT flag are ignored. Therefore the user have to set or unset this flag if needed. All facets that get visited during this algorithm are marked as VISIT and the Visit() method of the given <a class="el" href="classMeshCore_1_1MeshFacetVisitor.html">MeshFacetVisitor</a> gets invoked. If there are no unvisited neighbours any more the algorithms returns immediately and returns the number of visited facets. </p><dl class="section note"><dt>Note</dt><dd>For the start facet <em>ulStartFacet</em> <a class="el" href="classMeshCore_1_1MeshFacetVisitor.html#afd6f873da75cb27ef33c201e740ae85d">MeshFacetVisitor::Visit()</a> does not get invoked though the facet gets marked as VISIT. </dd></dl>

</div>
</div>
<a id="a627b2a72b7ce3c644f32a05f6b8ac5d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627b2a72b7ce3c644f32a05f6b8ac5d9">&#9670;&nbsp;</a></span>VisitNeighbourFacetsOverCorners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MeshCore::MeshKernel::VisitNeighbourFacetsOverCorners </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMeshCore_1_1MeshFacetVisitor.html">MeshFacetVisitor</a> &amp;&#160;</td>
          <td class="paramname"><em>rclFVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulStartFacet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Does basically the same as the method above unless the facets that share just a common point are regared as neighbours. </p>

</div>
</div>
<a id="ac6a54337416177caefb3015d5a50fd67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a54337416177caefb3015d5a50fd67">&#9670;&nbsp;</a></span>VisitNeighbourPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long MeshCore::MeshKernel::VisitNeighbourPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMeshCore_1_1MeshPointVisitor.html">MeshPointVisitor</a> &amp;&#160;</td>
          <td class="paramname"><em>rclPVisitor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>ulStartPoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method visits all neighbour points starting from the point associated to index <em>ulStartPoint</em>. All points having set the VISIT flag are ignored. Therefore the user have to set or unset this flag if needed before the algorithm starts. All points that get visited during this algorithm are marked as VISIT and the Visit() method of the given <a class="el" href="classMeshCore_1_1MeshPointVisitor.html">MeshPointVisitor</a> gets invoked. If there are no unvisited neighbours any more the algorithms returns immediately and returns the number of visited points. </p><dl class="section note"><dt>Note</dt><dd>For the start facet <em>ulStartPoint</em> <a class="el" href="classMeshCore_1_1MeshPointVisitor.html#a148f043123aa53821ebf668cd85f9010">MeshPointVisitor::Visit()</a> does not get invoked though the point gets marked as VISIT. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a70c2436935a29ba0f7e971869d63c3ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c2436935a29ba0f7e971869d63c3ec">&#9670;&nbsp;</a></span>_aclFacetArray</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshFacetArray.html">MeshFacetArray</a> MeshCore::MeshKernel::_aclFacetArray</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Holds the array of facets. </p>

</div>
</div>
<a id="a2510fa1fe417b92b9e8f68ac516b4105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2510fa1fe417b92b9e8f68ac516b4105">&#9670;&nbsp;</a></span>_aclPointArray</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMeshCore_1_1MeshPointArray.html">MeshPointArray</a> MeshCore::MeshKernel::_aclPointArray</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Holds the array of geometric points. </p>

</div>
</div>
<a id="a95d473a8c2afb9da7215410619591a92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d473a8c2afb9da7215410619591a92">&#9670;&nbsp;</a></span>_bValid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MeshCore::MeshKernel::_bValid</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Current state of validality. </p>

</div>
</div>
<a id="a0a3d9f6704dbe2fbeea38de27ebdcb72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3d9f6704dbe2fbeea38de27ebdcb72">&#9670;&nbsp;</a></span>_clBoundBox</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBase_1_1BoundBox3.html">Base::BoundBox3f</a> MeshCore::MeshKernel::_clBoundBox</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The current calculated bounding box. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 1 2019 13:31:56 for FreeCAD C++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
